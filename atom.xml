<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JaxRunboo&#39;s blog</title>
  
  <subtitle>farmer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.smallapp.xyz/"/>
  <updated>2020-04-07T02:03:56.903Z</updated>
  <id>https://www.smallapp.xyz/</id>
  
  <author>
    <name>JaxRunboo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志</title>
    <link href="https://www.smallapp.xyz/2020/04/07/2.4%E6%97%A5%E5%BF%97/"/>
    <id>https://www.smallapp.xyz/2020/04/07/2.4%E6%97%A5%E5%BF%97/</id>
    <published>2020-04-06T16:00:00.000Z</published>
    <updated>2020-04-07T02:03:56.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>ABP使用Castle Windsor的日志记录工具。它可以和不同的日志库一起工作：Log4Net, NLog, Serilog等等。Castle为所有的日志库提供了一个公共的接口。通过这种方式，你可以独立使用一个特殊的日志库，并且轻松的替换它。</p><p><a href="http://logging.apache.org/log4net/" target="_blank" rel="noopener">Log4Net</a>是最受欢迎的日志库之一。log4net的依赖只需要一行代码（ 如配置部分所示），因此你可以轻松替换成你喜欢的库。</p><h2 id="获得Logger"><a href="#获得Logger" class="headerlink" title="获得Logger"></a>获得Logger</h2><p>不论你选用哪种日志库，写入日志的代码是相同的(感谢Castle的公共ILogger接口).</p><p>首先，我们需要取得一个Logger对象来记录日志。因为ABP热衷于使用依赖注入，我们可以使用属性注入(或者构造函数注入)方式，轻松地注入一个Logger对象。这是一个写日志的简单例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">using Castle.Core.Logging; &#x2F;&#x2F;1: Import Logging namespace</span><br><span class="line"></span><br><span class="line">public class TaskAppService : ITaskAppService</span><br><span class="line">&#123;    </span><br><span class="line">    &#x2F;&#x2F;2: Getting a logger using property injection</span><br><span class="line">    public ILogger Logger &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public TaskAppService()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;3: Do not write logs if no Logger supplied.</span><br><span class="line">        Logger &#x3D; NullLogger.Instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void CreateTask(CreateTaskInput input)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;4: Write logs</span><br><span class="line">        Logger.Info(&quot;Creating a new task with description: &quot; + input.Description);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;TODO: save task to database...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先</strong>，引入Castle的Logger接口的命名空间。<br><strong>然后</strong>，定义一个public ILogger对象，命名为Logger。这是我们将用来写入日志的对象。依赖注入系统会在创建TaskAppService对象后注入这个属性。这是属性注入的方式。<br><strong>第三步</strong>,设置Logger为NullLogger.Instance。没有这一行，系统仍旧会正常工作，但是使用属性注入的方式是最佳实践。如果Logger没有设定值，Logger会是null，当我们想要使用他的时候，我们会获得一个”object reference…”的exception。这确保它不能为空。<br>如果没有日志库的内容给到Logger，它将会是NullLogger。这被成为空对象模式。NullLogger不做任何事。它不写入日志。采用这种方式，不论是否使用日志工具，我们都可以正常工作。<br><strong>最后</strong>,我们使用信息等级来写一个日志文本。有不同的等级(查看配置部分)。</p><p>如果我们调用CreateTask方法并查看日志文件，我们会看到一条日志行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  2014-07-13 13:40:23,360 [8    ] SimpleTaskSystem.Tasks.TaskAppService    - Creating a new task with description: Remember to drink milk before sleeping!</span><br></pre></td></tr></table></figure><h2 id="使用Logger的基类"><a href="#使用Logger的基类" class="headerlink" title="使用Logger的基类"></a>使用Logger的基类</h2><p>ABP为MVC controller、Web API controller，应用服务类及其他内容计通了基类。它声明了一个Logger属性。使用这种方式，你可以直接使用这个Logger来写日志，不需要注入。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HomeController : SimpleTaskSystemControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    public ActionResult Index()</span><br><span class="line">    &#123;</span><br><span class="line">        Logger.Debug(&quot;A sample log message...&quot;);</span><br><span class="line">        return View();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意SimpleTaskSystemControllerBase是我们的应用特定的基controller，继承了AbpController。用这种方式，它可以直接使用Logger。你可以为了其他的类写你自己的公共基类.之后你将不需要次次注入一个logger。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>当你使用ABP创建你的应用时，所有的Log4Net的配置都已经写好了。<br>默认的配置日志格式如下：</p><ul><li><strong>日志等级</strong>:DEBUG, INFO, WARN, ERROR or FATAL.</li><li><strong>Date and time</strong>: 日志写入时间.</li><li><strong>线程号</strong>：写入日支行的线程号.</li><li><strong>日志文本</strong>:你写入的实际日志文本.<br>在应用的log4net.config文件中定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot; ?&gt;</span><br><span class="line">&lt;log4net&gt;</span><br><span class="line">  &lt;appender name&#x3D;&quot;RollingFileAppender&quot; type&#x3D;&quot;log4net.Appender.RollingFileAppender&quot; &gt;</span><br><span class="line">    &lt;file value&#x3D;&quot;Logs&#x2F;Logs.txt&quot; &#x2F;&gt;</span><br><span class="line">    &lt;appendToFile value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">    &lt;rollingStyle value&#x3D;&quot;Size&quot; &#x2F;&gt;</span><br><span class="line">    &lt;maxSizeRollBackups value&#x3D;&quot;10&quot; &#x2F;&gt;</span><br><span class="line">    &lt;maximumFileSize value&#x3D;&quot;10000KB&quot; &#x2F;&gt;</span><br><span class="line">    &lt;staticLogFileName value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">    &lt;layout type&#x3D;&quot;log4net.Layout.PatternLayout&quot;&gt;</span><br><span class="line">        &lt;conversionPattern value&#x3D;&quot;%-5level %date [%-5.5thread] %-40.40logger - %message%newline&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;layout&gt;</span><br><span class="line">  &lt;&#x2F;appender&gt;</span><br><span class="line">  &lt;root&gt;</span><br><span class="line">    &lt;appender-ref ref&#x3D;&quot;RollingFileAppender&quot; &#x2F;&gt;</span><br><span class="line">    &lt;level value&#x3D;&quot;DEBUG&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;root&gt;</span><br><span class="line">  &lt;logger name&#x3D;&quot;NHibernate&quot;&gt;</span><br><span class="line">    &lt;level value&#x3D;&quot;WARN&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;logger&gt;</span><br><span class="line">&lt;&#x2F;log4net&gt;</span><br></pre></td></tr></table></figure></li></ul><p>Log4Net是一个高度可配置的强大的日志库。你可以使用不同格式写入不同的目标(文本文件、数据库…)。你可以设置最小的日志等级(正如在这个为NHibernate的配置中)。你可以将不同的loggers写入不同的文件。当达到特定的大小(在这个RollingFileAppender配置中每个文件最多包含10000kb)，它可以自动备份文件，创建新的日志文件等等。请阅读它自己的<a href="http://logging.apache.org/log4net/release/config-examples.html" target="_blank" rel="noopener">配置文档</a>以获得更多信息。</p><p>最后，在Global.asax文件中，我们声明我们使用Log4Net，它的配置文件为log4net.config：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MvcApplication : AbpWebApplication</span><br><span class="line">&#123;</span><br><span class="line">    protected override void Application_Start(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        IocManager.Instance.IocContainer.AddFacility&lt;LoggingFacility&gt;(f &#x3D;&gt; f.UseLog4Net().WithConfig(&quot;log4net.config&quot;));</span><br><span class="line">        base.Application_Start(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们依赖log4net的唯一的一行代码。只有web项目依赖log4net库的包。你也可以无需改动日志使用代码，轻松修改到其他库。</p><h2 id="Abp-Castle-Log4Net包"><a href="#Abp-Castle-Log4Net包" class="headerlink" title="Abp.Castle.Log4Net包"></a>Abp.Castle.Log4Net包</h2><p>ABP使用Castle日志记录工具，它不是直接依赖log4net，如上文声明。然而，Castle的Log4net集成存在一个问题，它不支持最新的log4net。我们创建了一个Nuget包，Abp.Castle.Log4Net，来解决这个问题。在添加这个包到我们的解决方案后，我们所做的内容仅仅是修改应用的start方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MvcApplication : AbpWebApplication</span><br><span class="line">&#123;</span><br><span class="line">    protected override void Application_Start(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        IocManager.Instance.IocContainer.AddFacility&lt;LoggingFacility&gt;(f &#x3D;&gt; f.UseAbpLog4Net().WithConfig(&quot;log4net.config&quot;));</span><br><span class="line">        base.Application_Start(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的区别是我们使用”UseAbpLog4Net()”(defined in Abp.Castle.Logging.Log4Net namespace)来代替”UseLog4Net()”。当我们使用”Abp.Castle.Log4Net”包，你不需要使用Castle.Windsor-log4net和Castle.Core-log4net包。</p><p>如果你需要在运行时修改你的log4net配置文件，想要在未重启应用时立刻产生影响，你可以像下面这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MvcApplication : AbpWebApplication</span><br><span class="line">&#123;</span><br><span class="line">    protected override void Application_Start(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        options.IocManager.IocContainer.AddFacility&lt;LoggingFacility&gt;(</span><br><span class="line">            f &#x3D;&gt; f.LogUsing(new Log4NetLoggerFactory(&quot;log4net.config&quot;, reloadOnChange:true))</span><br><span class="line">        );</span><br><span class="line">        base.Application_Start(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>ABP为客户端定义了一个简单的JS日志API。它默认在浏览器的console中记录日志。这是一些写入日志的JS代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp.log.warn(<span class="string">'a sample log message...'</span>);</span><br></pre></td></tr></table></figure><p>有关更多信息，请参阅<a href="http://logging.apache.org/log4net/release/config-examples.html" target="_blank" rel="noopener">日志API文档</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务器端&quot;&gt;&lt;a href=&quot;#服务器端&quot; class=&quot;headerlink&quot; title=&quot;服务器端&quot;&gt;&lt;/a&gt;服务器端&lt;/h2&gt;&lt;p&gt;ABP使用Castle Windsor的日志记录工具。它可以和不同的日志库一起工作：Log4Net, NLog, Seril
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>1155 想要判断给出的binary tree是否是一个heap</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1155HeapPaths/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1155HeapPaths/</id>
    <published>2020-03-31T02:55:32.734Z</published>
    <updated>2020-04-02T03:47:24.388Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <h5 id="自行分析：-根据root和第二个节点就可以假设tree是最大堆（最小堆），"><a href="#自行分析：-根据root和第二个节点就可以假设tree是最大堆（最小堆），" class="headerlink" title="自行分析： 根据root和第二个节点就可以假设tree是最大堆（最小堆），"></a>自行分析： 根据root和第二个节点就可以假设tree是最大堆（最小堆），</h5><h5 id="然后，采用递归的方式，父元素与子元素进行比较，父元素-gt-lt-子元素，可继续比较-直到子元素为空。"><a href="#然后，采用递归的方式，父元素与子元素进行比较，父元素-gt-lt-子元素，可继续比较-直到子元素为空。" class="headerlink" title="然后，采用递归的方式，父元素与子元素进行比较，父元素&gt;=(&lt;=)子元素，可继续比较,直到子元素为空。"></a>然后，采用递归的方式，父元素与子元素进行比较，父元素&gt;=(&lt;=)子元素，可继续比较,直到子元素为空。</h5><h5 id="若不满足情况，则认为非最大堆（最小堆）"><a href="#若不满足情况，则认为非最大堆（最小堆）" class="headerlink" title="若不满足情况，则认为非最大堆（最小堆）"></a>若不满足情况，则认为非最大堆（最小堆）</h5><h5 id="柳婼版分析："><a href="#柳婼版分析：" class="headerlink" title="柳婼版分析："></a>柳婼版分析：</h5><h5 id="1-数组存储堆，使用vector，深搜回溯，直接显示paths"><a href="#1-数组存储堆，使用vector，深搜回溯，直接显示paths" class="headerlink" title="1. 数组存储堆，使用vector，深搜回溯，直接显示paths"></a>1. 数组存储堆，使用vector，深搜回溯，直接显示paths</h5><h5 id="2-根据index，对数组数据循环判断堆的类型"><a href="#2-根据index，对数组数据循环判断堆的类型" class="headerlink" title="2. 根据index，对数组数据循环判断堆的类型"></a>2. 根据index，对数组数据循环判断堆的类型</h5><blockquote><p>自制版：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeapNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Index leftChildIndex;</span><br><span class="line">    Index rightChildIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果1:与increase顺序相同 -1:表示不同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ChargeAndShowOnePath</span><span class="params">(Index index,HeapNode arr[],<span class="keyword">int</span> increase)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*1.判断是否是叶子节点</span></span><br><span class="line"><span class="comment">    2.向上查找父节点，同时将index入栈</span></span><br><span class="line"><span class="comment">    3.出栈时比较大小，作为大小判断的结果*/</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; paths;</span><br><span class="line">    <span class="keyword">int</span> firstNum;</span><br><span class="line">    <span class="keyword">int</span> secondNum;</span><br><span class="line">    <span class="keyword">int</span> res =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        paths.push(index);</span><br><span class="line">        index/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!paths.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        firstNum = paths.top();</span><br><span class="line">        paths.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[firstNum].value&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!paths.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        secondNum = paths.top();</span><br><span class="line">        paths.pop();</span><br><span class="line">        <span class="keyword">if</span>(increase==<span class="number">1</span>&amp;&amp; arr[secondNum].value&gt;arr[firstNum].value)</span><br><span class="line">        &#123;</span><br><span class="line">            res= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(increase==<span class="number">-1</span>&amp;&amp; arr[secondNum].value&lt;arr[firstNum].value)</span><br><span class="line">        &#123;</span><br><span class="line">            res= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;arr[secondNum].value;</span><br><span class="line">        <span class="keyword">if</span>(!paths.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        firstNum = secondNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindTreeChild</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s,HeapNode arr[],<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[index].leftChildIndex==<span class="number">-1</span>&amp;&amp;arr[index].rightChildIndex==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s.push(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[index].leftChildIndex!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FindTreeChild(s,arr,index*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[index].rightChildIndex!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FindTreeChild(s,arr,index*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> heapEleNum;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;heapEleNum;</span><br><span class="line">    HeapNode arr[heapEleNum+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> increase;</span><br><span class="line">    <span class="keyword">int</span> obey =<span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; indexS;</span><br><span class="line">    <span class="comment">//stack&lt;int&gt; &amp;indexS1 = indexS;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=heapEleNum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;value;</span><br><span class="line">        arr[i].value = value;</span><br><span class="line">        arr[i].leftChildIndex = <span class="number">2</span>*i&gt;heapEleNum?<span class="number">-1</span>:<span class="number">2</span>*i;</span><br><span class="line">        arr[i].rightChildIndex = (<span class="number">2</span>*i+<span class="number">1</span>)&gt;heapEleNum?<span class="number">-1</span>:(<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FindTreeChild(indexS,arr,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    increase = arr[<span class="number">1</span>].value&gt; arr[<span class="number">2</span>].value? <span class="number">1</span>:(arr[<span class="number">1</span>].value&lt;arr[<span class="number">2</span>].value?<span class="number">-1</span>:<span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!indexS.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> needindex = indexS.top();</span><br><span class="line">        indexS.pop();</span><br><span class="line">        <span class="keyword">int</span> result  = ChargeAndShowOnePath(needindex,arr,increase);</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            obey = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obey==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(increase==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Max Heap"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Min Heap"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not Heap"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>柳婼版:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1009</span>], n, isMin = <span class="number">1</span>, isMax = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index * <span class="number">2</span> &gt; n &amp;&amp; index * <span class="number">2</span> + <span class="number">1</span> &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, v[i], i != v.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">" "</span> : <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(a[index * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        dfs(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        v.pop_back();</span><br><span class="line">        v.push_back(a[index * <span class="number">2</span>]);</span><br><span class="line">        dfs(index * <span class="number">2</span>);</span><br><span class="line">        v.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    v.push_back(a[<span class="number">1</span>]);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i/<span class="number">2</span>] &gt; a[i])</span><br><span class="line">            isMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i/<span class="number">2</span>] &lt; a[i])</span><br><span class="line">            isMax = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMin == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Min Heap"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, isMax == <span class="number">1</span> ? <span class="string">"Max Heap"</span> : <span class="string">"Not Heap"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;h5 id=&quot;自行分析：-根据root和第二个节点就可以假设tree是最大堆（最小堆），&quot;&gt;&lt;a href=&quot;#自行分析：-根据root和第二个节点就可以假设tree是最大堆（最小堆），&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1151 LCA in Binray Tree</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1151lcaInBinaryTree/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1151lcaInBinaryTree/</id>
    <published>2020-03-31T02:55:32.720Z</published>
    <updated>2020-04-02T03:46:58.607Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><h5 id="1-给定了前序和中序，得到唯一的二叉树结构"><a href="#1-给定了前序和中序，得到唯一的二叉树结构" class="headerlink" title="1.给定了前序和中序，得到唯一的二叉树结构"></a>1.给定了前序和中序，得到唯一的二叉树结构</h5><h5 id="2-获得的请求lca的数据，逐条执行"><a href="#2-获得的请求lca的数据，逐条执行" class="headerlink" title="2.获得的请求lca的数据，逐条执行"></a>2.获得的请求lca的数据，逐条执行</h5><h5 id="柳诺版本分析："><a href="#柳诺版本分析：" class="headerlink" title="柳诺版本分析："></a>柳诺版本分析：</h5><h5 id="lca方法：-无需得出二叉树，根据前序和中序可以得到二叉树的root节点，相对复杂的点是root节点位置的计算"><a href="#lca方法：-无需得出二叉树，根据前序和中序可以得到二叉树的root节点，相对复杂的点是root节点位置的计算" class="headerlink" title="lca方法： 无需得出二叉树，根据前序和中序可以得到二叉树的root节点，相对复杂的点是root节点位置的计算"></a>lca方法： 无需得出二叉树，根据前序和中序可以得到二叉树的root节点，相对复杂的点是root节点位置的计算</h5><h5 id="1-若u和v在root的左侧，获取左侧子二叉树的root节点，重新使用u、v进行比较"><a href="#1-若u和v在root的左侧，获取左侧子二叉树的root节点，重新使用u、v进行比较" class="headerlink" title="1.若u和v在root的左侧，获取左侧子二叉树的root节点，重新使用u、v进行比较"></a>1.若u和v在root的左侧，获取左侧子二叉树的root节点，重新使用u、v进行比较</h5><h5 id="2-若u和v在root的两侧，则u、v的lca为root"><a href="#2-若u和v在root的两侧，则u、v的lca为root" class="headerlink" title="2.若u和v在root的两侧，则u、v的lca为root"></a>2.若u和v在root的两侧，则u、v的lca为root</h5><h5 id="3-若u和v在root的右侧，获取右侧子二叉树的root节点，重新使用u、v进行比较"><a href="#3-若u和v在root的右侧，获取右侧子二叉树的root节点，重新使用u、v进行比较" class="headerlink" title="3.若u和v在root的右侧，获取右侧子二叉树的root节点，重新使用u、v进行比较"></a>3.若u和v在root的右侧，获取右侧子二叉树的root节点，重新使用u、v进行比较</h5><h5 id="4-若u或者v不存在，输出u、v不存在的结论"><a href="#4-若u或者v不存在，输出u、v不存在的结论" class="headerlink" title="4.若u或者v不存在，输出u、v不存在的结论"></a>4.若u或者v不存在，输出u、v不存在的结论</h5><h5 id="使用两个vector分别存储前序和中序，使用一个map-lt-value-index-gt-来存储前序的值在中序中对应的位置"><a href="#使用两个vector分别存储前序和中序，使用一个map-lt-value-index-gt-来存储前序的值在中序中对应的位置" class="headerlink" title="使用两个vector分别存储前序和中序，使用一个map&lt;value,index&gt;来存储前序的值在中序中对应的位置"></a>使用两个vector分别存储前序和中序，使用一个map&lt;value,index&gt;来存储前序的值在中序中对应的位置</h5><blockquote><p>柳神版代码：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,in;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="keyword">int</span> m,n,a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> inl,<span class="keyword">int</span> inr,<span class="keyword">int</span> preRoot,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inl&gt;inr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> rootIndex = pos[pre[preRoot]];</span><br><span class="line">    <span class="keyword">int</span> aIndex = pos[a];</span><br><span class="line">    <span class="keyword">int</span> bIndex =pos[b];</span><br><span class="line">    <span class="keyword">if</span>(aIndex&lt;rootIndex&amp;&amp;bIndex&lt; rootIndex)</span><br><span class="line">        lca(inl,rootIndex<span class="number">-1</span>,preRoot+<span class="number">1</span>,a,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((aIndex&lt;rootIndex&amp;&amp;bIndex&gt;rootIndex)||(aIndex&gt;rootIndex&amp;&amp;bIndex&lt;rootIndex))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>,a,b,pre[preRoot]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aIndex&gt;rootIndex&amp;&amp;bIndex&gt; rootIndex)</span><br><span class="line">        lca(rootIndex+<span class="number">1</span>,inr,preRoot+<span class="number">1</span>+(rootIndex-inl),a,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(aIndex==rootIndex)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>,a,b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bIndex == rootIndex)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>,b,a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    pre.resize(n+<span class="number">1</span>);</span><br><span class="line">    in.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> arr[m][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;in[i];</span><br><span class="line">        pos[in[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;pre[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i][<span class="number">0</span>]&gt;&gt;arr[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a=arr[i][<span class="number">0</span>];</span><br><span class="line">        b=arr[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(pos[a]==<span class="number">0</span>&amp;&amp;pos[b]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>,a,b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pos[a]==<span class="number">0</span>||pos[b]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>,pos[a]==<span class="number">0</span>?a:b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lca(<span class="number">1</span>,n,<span class="number">1</span>,a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：&quot;&gt;&lt;a href=&quot;#分析：&quot; class=&quot;headerlink&quot; title=&quot;分析：&quot;&gt;&lt;/a&gt;分析：&lt;/h5&gt;&lt;h5 id=&quot;1-给定了前序和中序，得到唯一的二叉树结构&quot;&gt;&lt;a href=&quot;#1-给定了前序和中序，得到唯一的二叉树结构&quot; class
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1147 Heaps</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1147Heaps/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1147Heaps/</id>
    <published>2020-03-31T02:55:32.712Z</published>
    <updated>2020-04-02T03:46:37.950Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><h5 id="给定了固定个数，固定元素数的完全二叉树，且按照层序遍历给出"><a href="#给定了固定个数，固定元素数的完全二叉树，且按照层序遍历给出" class="headerlink" title="给定了固定个数，固定元素数的完全二叉树，且按照层序遍历给出"></a>给定了固定个数，固定元素数的完全二叉树，且按照层序遍历给出</h5><h5 id="判断其是什么堆？且按照后续遍历给出"><a href="#判断其是什么堆？且按照后续遍历给出" class="headerlink" title="判断其是什么堆？且按照后续遍历给出"></a>判断其是什么堆？且按照后续遍历给出</h5><h5 id="数目固定，使用二维数组（初始化为0），不存在空间浪费，后续遍历输出即可"><a href="#数目固定，使用二维数组（初始化为0），不存在空间浪费，后续遍历输出即可" class="headerlink" title="数目固定，使用二维数组（初始化为0），不存在空间浪费，后续遍历输出即可"></a>数目固定，使用二维数组（初始化为0），不存在空间浪费，后续遍历输出即可</h5><h5 id="柳神版分析：思路大体相同，但相对而言，空间和时间利用率更佳"><a href="#柳神版分析：思路大体相同，但相对而言，空间和时间利用率更佳" class="headerlink" title="柳神版分析：思路大体相同，但相对而言，空间和时间利用率更佳"></a>柳神版分析：思路大体相同，但相对而言，空间和时间利用率更佳</h5><h5 id="1-判断堆类型时，采用n-2个循环计算"><a href="#1-判断堆类型时，采用n-2个循环计算" class="headerlink" title="1.判断堆类型时，采用n/2个循环计算"></a>1.判断堆类型时，采用n/2个循环计算</h5><h5 id="2-重复利用vector，不需要二维数组"><a href="#2-重复利用vector，不需要二维数组" class="headerlink" title="2.重复利用vector，不需要二维数组"></a>2.重复利用vector<int>，不需要二维数组</h5><blockquote><p>自制版：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">100</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfArr</span><span class="params">(<span class="keyword">int</span> arrNew[],<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PrintfArr(arrNew,index*<span class="number">2</span>);</span><br><span class="line">    PrintfArr(arrNew,index*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arrNew[index];</span><br><span class="line">    <span class="keyword">if</span>(index&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1 min 1 max 0 not</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Charge</span><span class="params">(<span class="keyword">int</span> arrNew[][<span class="number">1001</span>],<span class="keyword">int</span> findex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isMin = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> isMax =  <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arrNew[findex][i/<span class="number">2</span>]&gt;arrNew[findex][i])</span><br><span class="line">            isMin = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(arrNew[findex][i/<span class="number">2</span>]&lt;arrNew[findex][i])</span><br><span class="line">            isMax = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isMin&amp;&amp;!isMax)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!isMin&amp;&amp;isMax)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n+<span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> res = Charge(arr,i);</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Max Heap"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(res ==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Min Heap"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Not Heap"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PrintfArr(arr[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>柳神版:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    postOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%s"</span>, v[index], index == <span class="number">0</span> ? <span class="string">"\n"</span> : <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    v.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v[j]);</span><br><span class="line">        <span class="keyword">int</span> flag = v[<span class="number">0</span>] &gt; v[<span class="number">1</span>] ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (n<span class="number">-1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = j * <span class="number">2</span> + <span class="number">1</span>, right = j * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; (v[j] &lt; v[left] || (right &lt; n &amp;&amp; v[j] &lt;</span><br><span class="line">                                                 v[right])))</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">-1</span> &amp;&amp; (v[j] &gt; v[left] || (right &lt; n &amp;&amp; v[j] &gt;</span><br><span class="line">                                                  v[right])))</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s Heap\n"</span>, flag == <span class="number">1</span> ? <span class="string">"Max"</span> : <span class="string">"Min"</span>);</span><br><span class="line">        postOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：&quot;&gt;&lt;a href=&quot;#分析：&quot; class=&quot;headerlink&quot; title=&quot;分析：&quot;&gt;&lt;/a&gt;分析：&lt;/h5&gt;&lt;h5 id=&quot;给定了固定个数，固定元素数的完全二叉树，且按照层序遍历给出&quot;&gt;&lt;a href=&quot;#给定了固定个数，固定元素数的完全二叉树，
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1138PostOrderTraversal</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1138PostOrderTraversal/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1138PostOrderTraversal/</id>
    <published>2020-03-31T02:55:32.698Z</published>
    <updated>2020-04-02T03:46:22.444Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析：已知前序和中序，求后序第一个应输出节点"><a href="#分析：已知前序和中序，求后序第一个应输出节点" class="headerlink" title="分析：已知前序和中序，求后序第一个应输出节点"></a>分析：已知前序和中序，求后序第一个应输出节点</h5><h5 id="1-无需先得到整体的二叉树，可递归求得最左侧-amp-amp-最底层的节点"><a href="#1-无需先得到整体的二叉树，可递归求得最左侧-amp-amp-最底层的节点" class="headerlink" title="1.无需先得到整体的二叉树，可递归求得最左侧&amp;&amp;最底层的节点"></a>1.无需先得到整体的二叉树，可递归求得最左侧&amp;&amp;最底层的节点</h5><h5 id="2-使用vector存储先序、中序，使用map-lt-int-int-gt-存储中序index和value"><a href="#2-使用vector存储先序、中序，使用map-lt-int-int-gt-存储中序index和value" class="headerlink" title="2.使用vector存储先序、中序，使用map&lt;int,int&gt;存储中序index和value"></a>2.使用vector<int>存储先序、中序，使用map&lt;int,int&gt;存储中序index和value</h5><h5 id="3-对先序的值逐个操作，与中序比对，对应处理"><a href="#3-对先序的值逐个操作，与中序比对，对应处理" class="headerlink" title="3.对先序的值逐个操作，与中序比对，对应处理"></a>3.对先序的值逐个操作，与中序比对，对应处理</h5><h5 id="柳神版分析："><a href="#柳神版分析：" class="headerlink" title="柳神版分析："></a>柳神版分析：</h5><h5 id="思路大致相同，关键点判断不同，其只采用两个vector存储先序中序，添加一个flag标签判断结束时机"><a href="#思路大致相同，关键点判断不同，其只采用两个vector存储先序中序，添加一个flag标签判断结束时机" class="headerlink" title="思路大致相同，关键点判断不同，其只采用两个vector存储先序中序，添加一个flag标签判断结束时机"></a>思路大致相同，关键点判断不同，其只采用两个vector存储先序中序，添加一个flag标签判断结束时机</h5><h5 id="自制版的思路来源是柳神的-1151LcaInBinaryTree-柳神版不使用map速度更快，空间占用小"><a href="#自制版的思路来源是柳神的-1151LcaInBinaryTree-柳神版不使用map速度更快，空间占用小" class="headerlink" title="自制版的思路来源是柳神的 1151LcaInBinaryTree,柳神版不使用map速度更快，空间占用小"></a>自制版的思路来源是柳神的 1151LcaInBinaryTree,柳神版不使用map速度更快，空间占用小</h5><blockquote><p>自制版</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n&lt;=50000</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,in;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deal</span><span class="params">(<span class="keyword">int</span> preRootIndex,<span class="keyword">int</span> leftIndex,<span class="keyword">int</span> rightIndex )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inIndex = pos[pre[preRootIndex]] ;</span><br><span class="line">    <span class="keyword">if</span>(inIndex-leftIndex&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        preRootIndex++;</span><br><span class="line">        rightIndex = inIndex<span class="number">-1</span>;</span><br><span class="line">        deal(preRootIndex,leftIndex,rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(inIndex-rightIndex&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        preRootIndex++;</span><br><span class="line">        leftIndex = inIndex +<span class="number">1</span>;</span><br><span class="line">        deal(preRootIndex,leftIndex,rightIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pre[preRootIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pre.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;pre[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;in[i];</span><br><span class="line">        pos[in[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deal(<span class="number">0</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>柳神版：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, in;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> prel, <span class="keyword">int</span> inl, <span class="keyword">int</span> inr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inl &gt; inr || flag == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = inl;</span><br><span class="line">    <span class="keyword">while</span> (in[i] != pre[prel])</span><br><span class="line">        i++;</span><br><span class="line">    postOrder(prel+<span class="number">1</span>, inl, i<span class="number">-1</span>);</span><br><span class="line">    postOrder(prel+i-inl+<span class="number">1</span>, i+<span class="number">1</span>, inr);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, in[i]);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    pre.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pre[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;in[i]);</span><br><span class="line">    postOrder(<span class="number">0</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：已知前序和中序，求后序第一个应输出节点&quot;&gt;&lt;a href=&quot;#分析：已知前序和中序，求后序第一个应输出节点&quot; class=&quot;headerlink&quot; title=&quot;分析：已知前序和中序，求后序第一个应输出节点&quot;&gt;&lt;/a&gt;分析：已知前序和中序，求后序第一个应输出
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1135 1135RedBlackTree</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1135RedBlackTree/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1135RedBlackTree/</id>
    <published>2020-03-31T02:55:32.696Z</published>
    <updated>2020-04-02T03:46:10.604Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析：判断给出的先序树是否是红黑树"><a href="#分析：判断给出的先序树是否是红黑树" class="headerlink" title="分析：判断给出的先序树是否是红黑树"></a>分析：判断给出的先序树是否是红黑树</h5><h5 id="这题好像有问题，为什么只给一个先序就可以直接对其进行判断了，连树的结构都没确定"><a href="#这题好像有问题，为什么只给一个先序就可以直接对其进行判断了，连树的结构都没确定" class="headerlink" title="这题好像有问题，为什么只给一个先序就可以直接对其进行判断了，连树的结构都没确定"></a>这题好像有问题，为什么只给一个先序就可以直接对其进行判断了，连树的结构都没确定</h5><h5 id="1-直接给出先序，采用链表存储"><a href="#1-直接给出先序，采用链表存储" class="headerlink" title="1.直接给出先序，采用链表存储"></a>1.直接给出先序，采用链表存储</h5><h5 id="2-考虑红黑树条件"><a href="#2-考虑红黑树条件" class="headerlink" title="2.考虑红黑树条件"></a>2.考虑红黑树条件</h5><h5 id="1-root为black，即-arr-0-gt-0"><a href="#1-root为black，即-arr-0-gt-0" class="headerlink" title="1) root为black，即 arr[0]&gt;0"></a>1) root为black，即 arr[0]&gt;0</h5><h5 id="2-arr-i-lt-0-则-arr-2i-1-和-arr-2i-都-gt-0"><a href="#2-arr-i-lt-0-则-arr-2i-1-和-arr-2i-都-gt-0" class="headerlink" title="2) arr[i]&lt;0,则 arr[2i+1]和 arr[2i]都&gt;0"></a>2) arr[i]&lt;0,则 arr[2i+1]和 arr[2i]都&gt;0</h5><h5 id="3-叶子节点（2i-gt-N）到root的路径，black-即-gt-0-的点要相等"><a href="#3-叶子节点（2i-gt-N）到root的路径，black-即-gt-0-的点要相等" class="headerlink" title="3) 叶子节点（2i&gt;N）到root的路径，black(即&gt;0)的点要相等"></a>3) 叶子节点（2i&gt;N）到root的路径，black(即&gt;0)的点要相等</h5><h2 id="懵了，不管"><a href="#懵了，不管" class="headerlink" title="懵了，不管"></a>懵了，不管</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：判断给出的先序树是否是红黑树&quot;&gt;&lt;a href=&quot;#分析：判断给出的先序树是否是红黑树&quot; class=&quot;headerlink&quot; title=&quot;分析：判断给出的先序树是否是红黑树&quot;&gt;&lt;/a&gt;分析：判断给出的先序树是否是红黑树&lt;/h5&gt;&lt;h5 id=&quot;这题好像有
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1127 ZigZagging on a Tree</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1127ZigZaggingTree/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1127ZigZaggingTree/</id>
    <published>2020-03-31T02:55:32.686Z</published>
    <updated>2020-04-02T03:45:18.239Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析：已知中序和后序，可得一个唯一的二叉树-对其按照层次，之字形输出结果"><a href="#分析：已知中序和后序，可得一个唯一的二叉树-对其按照层次，之字形输出结果" class="headerlink" title="分析：已知中序和后序，可得一个唯一的二叉树,对其按照层次，之字形输出结果"></a>分析：已知中序和后序，可得一个唯一的二叉树,对其按照层次，之字形输出结果</h5><h5 id="1-根据中序和后序建树，保存在二维数组中"><a href="#1-根据中序和后序建树，保存在二维数组中" class="headerlink" title="1.根据中序和后序建树，保存在二维数组中"></a>1.根据中序和后序建树，保存在二维数组中</h5><h5 id="2-层序遍历要使用队列来实现"><a href="#2-层序遍历要使用队列来实现" class="headerlink" title="2.层序遍历要使用队列来实现"></a>2.层序遍历要使用队列来实现</h5><h5 id="3-还需要一个二维数组来存储每层的结果，用来实现zigzag"><a href="#3-还需要一个二维数组来存储每层的结果，用来实现zigzag" class="headerlink" title="3.还需要一个二维数组来存储每层的结果，用来实现zigzag"></a>3.还需要一个二维数组来存储每层的结果，用来实现zigzag</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in,post,result[<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">35</span>][<span class="number">2</span>],n,rootIndex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> depth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;index,<span class="keyword">int</span> inLeftIndex,<span class="keyword">int</span> inRightIndex,<span class="keyword">int</span> postLeftIndex,<span class="keyword">int</span> postRightIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inLeftIndex&gt;inRightIndex)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    index = postRightIndex;</span><br><span class="line">    <span class="comment">//inIndex</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(in[i]!=post[postRightIndex])</span><br><span class="line">        i++;</span><br><span class="line">    dfs(tree[index][<span class="number">0</span>],inLeftIndex,i<span class="number">-1</span>,postLeftIndex,index-(inRightIndex - i)<span class="number">-1</span>);</span><br><span class="line">    dfs(tree[index][<span class="number">1</span>],i+<span class="number">1</span>,inRightIndex,index-(inRightIndex - i),postRightIndex<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用队列，进行层序遍历</span></span><br><span class="line">    <span class="comment">//当前数组还是一个post的顺序，将其变为层序，保存到result中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q ;</span><br><span class="line">    q.push(Node&#123;rootIndex,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node node =  q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        result[node.depth].push_back(post[node.index]);</span><br><span class="line">        <span class="keyword">if</span>(tree[node.index][<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">            q.push(Node&#123;tree[node.index][<span class="number">0</span>],node.depth+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(tree[node.index][<span class="number">1</span>]!=<span class="number">0</span>)</span><br><span class="line">            q.push(Node&#123;tree[node.index][<span class="number">1</span>],node.depth+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    in.resize(n+<span class="number">1</span>);</span><br><span class="line">    post.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;post[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深搜获取唯一二叉树</span></span><br><span class="line">    dfs(rootIndex,<span class="number">1</span>,n,<span class="number">1</span> ,n);</span><br><span class="line">    <span class="comment">//广搜得到层次结构</span></span><br><span class="line">    bfs();</span><br><span class="line">    <span class="comment">//按要求输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">35</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> ==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;result[i].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,result[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=result[i].<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,result[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：已知中序和后序，可得一个唯一的二叉树-对其按照层次，之字形输出结果&quot;&gt;&lt;a href=&quot;#分析：已知中序和后序，可得一个唯一的二叉树-对其按照层次，之字形输出结果&quot; class=&quot;headerlink&quot; title=&quot;分析：已知中序和后序，可得一个唯一的二叉
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1119 Pre and Post-order Traversals</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1119PreAndPostorderTraversals/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1119PreAndPostorderTraversals/</id>
    <published>2020-03-31T02:55:32.677Z</published>
    <updated>2020-04-02T03:45:01.603Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析：已知先序和后序，求中序"><a href="#分析：已知先序和后序，求中序" class="headerlink" title="分析：已知先序和后序，求中序"></a>分析：已知先序和后序，求中序</h5><h5 id="需要知道，如何判断这个中序是否不唯一-先序的首位和后序的末位相等，为根元素。之后先序后推一位，后序前推一位。当两值相等-此时便无法区分到底是左子树还是右子树"><a href="#需要知道，如何判断这个中序是否不唯一-先序的首位和后序的末位相等，为根元素。之后先序后推一位，后序前推一位。当两值相等-此时便无法区分到底是左子树还是右子树" class="headerlink" title="需要知道，如何判断这个中序是否不唯一.先序的首位和后序的末位相等，为根元素。之后先序后推一位，后序前推一位。当两值相等,此时便无法区分到底是左子树还是右子树"></a>需要知道，如何判断这个中序是否不唯一.先序的首位和后序的末位相等，为根元素。之后先序后推一位，后序前推一位。当两值相等,此时便无法区分到底是左子树还是右子树</h5><h5 id="即不能够唯一断定，某子节点是左节点还是右节点"><a href="#即不能够唯一断定，某子节点是左节点还是右节点" class="headerlink" title="即不能够唯一断定，某子节点是左节点还是右节点"></a>即不能够唯一断定，某子节点是左节点还是右节点</h5><h5 id="vector存储pre，post，in"><a href="#vector存储pre，post，in" class="headerlink" title="vector存储pre，post，in"></a>vector存储pre，post，in</h5><h5 id="算法中自定义出现不唯一时认定其为左子树"><a href="#算法中自定义出现不唯一时认定其为左子树" class="headerlink" title="算法中自定义出现不唯一时认定其为左子树"></a>算法中自定义出现不唯一时认定其为左子树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,post,in;</span><br><span class="line"><span class="keyword">bool</span> uniqueT = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Charge</span><span class="params">(<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> postL,<span class="keyword">int</span> postR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL==preR)</span><br><span class="line">    &#123;</span><br><span class="line">        in.push_back(pre[preL]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两端相等也认定为左子树</span></span><br><span class="line">    <span class="keyword">if</span>(pre[preL]==post[postR])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根节点确定，考虑子树情况</span></span><br><span class="line">        <span class="keyword">if</span>(pre[preL+<span class="number">1</span>]== post[postR<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            uniqueT = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//意味着剩下的全是左子树的内容</span></span><br><span class="line">            Charge(preL+<span class="number">1</span>,preR,postL,postR<span class="number">-1</span>);<span class="comment">//左</span></span><br><span class="line">            in.push_back(pre[preL]);<span class="comment">//根</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pre[preL+i]!=post[postR<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i=i<span class="number">-1</span>;</span><br><span class="line">            Charge(preL+<span class="number">1</span>,preL+i,postL,postL+i<span class="number">-1</span>);<span class="comment">//左子树</span></span><br><span class="line">            in.push_back(pre[preL]);<span class="comment">//根节点</span></span><br><span class="line">            Charge(preL+i+<span class="number">1</span>,preR,postL+i,postR<span class="number">-1</span>);<span class="comment">//右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    pre.resize(n+ <span class="number">1</span>);</span><br><span class="line">    post.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;pre[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;post[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断并存储</span></span><br><span class="line">    Charge(<span class="number">1</span>,n,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">if</span>(uniqueT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;in[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;in.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;in[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：已知先序和后序，求中序&quot;&gt;&lt;a href=&quot;#分析：已知先序和后序，求中序&quot; class=&quot;headerlink&quot; title=&quot;分析：已知先序和后序，求中序&quot;&gt;&lt;/a&gt;分析：已知先序和后序，求中序&lt;/h5&gt;&lt;h5 id=&quot;需要知道，如何判断这个中序是否不唯
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1115 Counting Nodes in a BST</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1115CountingNodesInBST/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1115CountingNodesInBST/</id>
    <published>2020-03-31T02:55:32.667Z</published>
    <updated>2020-04-02T03:44:33.551Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析：左子树小于父节点，右子树大于父节点"><a href="#分析：左子树小于父节点，右子树大于父节点" class="headerlink" title="分析：左子树小于父节点，右子树大于父节点"></a>分析：左子树小于父节点，右子树大于父节点</h5><h5 id="链表存储自定义节点，存储bst，递归构建"><a href="#链表存储自定义节点，存储bst，递归构建" class="headerlink" title="链表存储自定义节点，存储bst，递归构建"></a>链表存储自定义节点，存储bst，递归构建</h5><h5 id="由根节点开始，dfs节点，并累计不同深度的系欸但数量"><a href="#由根节点开始，dfs节点，并累计不同深度的系欸但数量" class="headerlink" title="由根节点开始，dfs节点，并累计不同深度的系欸但数量"></a>由根节点开始，dfs节点，并累计不同深度的系欸但数量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int n;&#x2F;&#x2F;&lt;&#x3D;1000</span><br><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct Node *left,*right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* Build(struct Node *root,int value)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        root &#x3D; new Node();</span><br><span class="line">        root-&gt;value &#x3D; value;</span><br><span class="line">        root-&gt;left &#x3D; NULL;</span><br><span class="line">        root-&gt;right &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(value &lt;&#x3D; root-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left&#x3D;  Build(root-&gt;left,value);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right &#x3D; Build(root-&gt;right,value);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; arr(1001);</span><br><span class="line">int maxDepth &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void DFS(struct Node *root,int depth)</span><br><span class="line">&#123;</span><br><span class="line">    if(root&#x3D;&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        maxDepth &#x3D; max(maxDepth,depth);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[depth]++;</span><br><span class="line">    DFS(root-&gt;left,depth+1);</span><br><span class="line">    DFS(root-&gt;right,depth+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int t;</span><br><span class="line">    Node *root &#x3D; NULL;</span><br><span class="line">    for(int i&#x3D;1; i&lt;&#x3D;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        root &#x3D; Build(root,t);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(root,1);</span><br><span class="line">    int b &#x3D; arr[maxDepth-1];</span><br><span class="line">    int a &#x3D; arr[maxDepth-2];</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0;i&lt;arr.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d + %d &#x3D; %d&quot;,b,a,a+b);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：左子树小于父节点，右子树大于父节点&quot;&gt;&lt;a href=&quot;#分析：左子树小于父节点，右子树大于父节点&quot; class=&quot;headerlink&quot; title=&quot;分析：左子树小于父节点，右子树大于父节点&quot;&gt;&lt;/a&gt;分析：左子树小于父节点，右子树大于父节点&lt;/h5&gt;&lt;
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1110 Complete Binary Tree</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1110CompleteBinaryTree/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1110CompleteBinaryTree/</id>
    <published>2020-03-31T02:55:32.650Z</published>
    <updated>2020-04-02T08:39:43.667Z</updated>
    
    <content type="html"><![CDATA[<h5 id="分析：每次可以获得一个-坐标-和左子树坐标和右子树坐标"><a href="#分析：每次可以获得一个-坐标-和左子树坐标和右子树坐标" class="headerlink" title="分析：每次可以获得一个 坐标 和左子树坐标和右子树坐标"></a>分析：每次可以获得一个 坐标 和左子树坐标和右子树坐标</h5><h5 id="判断是否是完全二叉树-是-返回树的最后一个节点坐标"><a href="#判断是否是完全二叉树-是-返回树的最后一个节点坐标" class="headerlink" title="判断是否是完全二叉树 是:返回树的最后一个节点坐标"></a>判断是否是完全二叉树 是:返回树的最后一个节点坐标</h5><h5 id="否-返回root坐标"><a href="#否-返回root坐标" class="headerlink" title="否:返回root坐标"></a>否:返回root坐标</h5><h5 id="gt-如何根据给定的数据，把数据构建成树"><a href="#gt-如何根据给定的数据，把数据构建成树" class="headerlink" title="=&gt; 如何根据给定的数据，把数据构建成树"></a>=&gt; 如何根据给定的数据，把数据构建成树</h5><h5 id="一个数组hasvalue-n-，根据输入结果判断是否是1，若1-n某一点不为1，即为根节点"><a href="#一个数组hasvalue-n-，根据输入结果判断是否是1，若1-n某一点不为1，即为根节点" class="headerlink" title="一个数组hasvalue[n]，根据输入结果判断是否是1，若1-n某一点不为1，即为根节点"></a>一个数组hasvalue[n]，根据输入结果判断是否是1，若1-n某一点不为1，即为根节点</h5><h5 id="一个二维数组存储输入值"><a href="#一个二维数组存储输入值" class="headerlink" title="一个二维数组存储输入值"></a>一个二维数组存储输入值</h5><h5 id="若为完全二叉树，dfs后得的最大元素index会比节点总数大"><a href="#若为完全二叉树，dfs后得的最大元素index会比节点总数大" class="headerlink" title="若为完全二叉树，dfs后得的最大元素index会比节点总数大"></a>若为完全二叉树，dfs后得的最大元素index会比节点总数大</h5><h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int arr[100][2];</span><br><span class="line">int maxn &#x3D; 0;&#x2F;&#x2F;最大index</span><br><span class="line">int ans;&#x2F;&#x2F;最大节点值在数组的index</span><br><span class="line"></span><br><span class="line">void DFS(int root,int index)</span><br><span class="line">&#123;</span><br><span class="line">    if(index&gt;maxn)</span><br><span class="line">    &#123;</span><br><span class="line">        maxn &#x3D; index;</span><br><span class="line">        ans &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr[root][0]!&#x3D; -1)</span><br><span class="line">        DFS(arr[root][0],index *2);</span><br><span class="line">    if(arr[root][1]!&#x3D; -1)</span><br><span class="line">        DFS(arr[root][1],index *2+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int root &#x3D; 0;</span><br><span class="line">    int hasvalue[100] &#x3D; &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    string left,right;</span><br><span class="line">    for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;left&gt;&gt;right;</span><br><span class="line">        if(left&#x3D;&#x3D;&quot;-&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][0]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][0] &#x3D; stoi(left);</span><br><span class="line">            hasvalue[arr[i][0]] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(right&#x3D;&#x3D;&quot;-&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][1]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][1] &#x3D; stoi(right);</span><br><span class="line">            hasvalue[arr[i][1]] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(hasvalue[root]!&#x3D;0)</span><br><span class="line">        root++;</span><br><span class="line">    DFS(root,1);</span><br><span class="line"></span><br><span class="line">    if(maxn&#x3D;&#x3D;n)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;YES %d&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">         printf(&quot;NO %d&quot;,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;分析：每次可以获得一个-坐标-和左子树坐标和右子树坐标&quot;&gt;&lt;a href=&quot;#分析：每次可以获得一个-坐标-和左子树坐标和右子树坐标&quot; class=&quot;headerlink&quot; title=&quot;分析：每次可以获得一个 坐标 和左子树坐标和右子树坐标&quot;&gt;&lt;/a&gt;分析：每次
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>1106 Lowest Price in Supply Chain</title>
    <link href="https://www.smallapp.xyz/2020/03/31/1106LowestPriceInSupplyChain/"/>
    <id>https://www.smallapp.xyz/2020/03/31/1106LowestPriceInSupplyChain/</id>
    <published>2020-03-31T02:55:32.648Z</published>
    <updated>2020-04-02T03:44:42.004Z</updated>
    
    <content type="html"><![CDATA[<h5 id="N-lt-10-10，可以使用vector二维数组存储数据"><a href="#N-lt-10-10，可以使用vector二维数组存储数据" class="headerlink" title="N&lt;10^10，可以使用vector二维数组存储数据"></a>N&lt;10^10，可以使用vector二维数组存储数据</h5><h5 id="万一末尾节点没有零售商？没有在考虑范围内，按照结果来看，零售商应该是叶子节点"><a href="#万一末尾节点没有零售商？没有在考虑范围内，按照结果来看，零售商应该是叶子节点" class="headerlink" title="万一末尾节点没有零售商？没有在考虑范围内，按照结果来看，零售商应该是叶子节点"></a>万一末尾节点没有零售商？没有在考虑范围内，按照结果来看，零售商应该是叶子节点</h5><h5 id="mindep表示层数-num表示叶节点个数"><a href="#mindep表示层数-num表示叶节点个数" class="headerlink" title="mindep表示层数  num表示叶节点个数"></a>mindep表示层数  num表示叶节点个数</h5><h5 id="需要注意结果精确位数"><a href="#需要注意结果精确位数" class="headerlink" title="需要注意结果精确位数"></a>需要注意结果精确位数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;&#x2F;&#x2F;节点数</span><br><span class="line">vector&lt;int&gt; arr[100000];</span><br><span class="line">int mindep &#x3D; 99999999;</span><br><span class="line">int num&#x3D;1;</span><br><span class="line"></span><br><span class="line">void DFS(int root,int depth)</span><br><span class="line">&#123;</span><br><span class="line">    if(mindep&lt;depth)</span><br><span class="line">        return;</span><br><span class="line">    if(arr[root].size() &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(mindep&gt;depth)</span><br><span class="line">        &#123;</span><br><span class="line">            mindep &#x3D; depth;</span><br><span class="line">            num &#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(mindep&#x3D;&#x3D; depth)</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0; i&lt;arr[root].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(arr[root][i],depth+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    double p,r;</span><br><span class="line">    scanf(&quot;%d %lf %lf&quot;,&amp;n,&amp;p,&amp;r);</span><br><span class="line">    for(int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int ln;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;ln);</span><br><span class="line"></span><br><span class="line">        for(int j&#x3D;0; j&lt;ln; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int index;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;index);</span><br><span class="line">            arr[i].push_back(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DFS(0,0);&#x2F;&#x2F;获取树</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.4f %d&quot;,p*pow((1+r&#x2F;100),mindep),num);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;N-lt-10-10，可以使用vector二维数组存储数据&quot;&gt;&lt;a href=&quot;#N-lt-10-10，可以使用vector二维数组存储数据&quot; class=&quot;headerlink&quot; title=&quot;N&amp;lt;10^10，可以使用vector二维数组存储数据&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>pta相关词汇</title>
    <link href="https://www.smallapp.xyz/2020/03/31/vocabulary/"/>
    <id>https://www.smallapp.xyz/2020/03/31/vocabulary/</id>
    <published>2020-03-31T02:55:32.645Z</published>
    <updated>2020-04-02T03:47:54.938Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>vocabulary 词汇<br>positive 正的;积极的<br>traversal 遍历<br>sequence 序列<br>occupy 占领、占用<br>argument 实参<br>parameter 形参<br>ancestor 祖先<br>descendant 后裔、子孙<br>respectively 分别的、各自的<br>postorder traversal sequence 后序遍历序列<br>corresponding 对应的，相应的；一致的<br>recursively 递归的<br>indices 标志，标记；迹象，征象，征候；指数，指标，率</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;vocabulary 词汇&lt;br&gt;positive 正的;积极的&lt;br&gt;traversal 遍历&lt;br&gt;sequence 序列&lt;br&gt;occupy 占领、占用&lt;br&gt;argument 实参&lt;br&gt;parameter 形参&lt;br&gt;ancestor 祖
      
    
    </summary>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/categories/pta/"/>
    
    
      <category term="pta" scheme="https://www.smallapp.xyz/tags/pta/"/>
    
  </entry>
  
  <entry>
    <title>调试</title>
    <link href="https://www.smallapp.xyz/2020/03/21/1.7%E8%B0%83%E8%AF%95/"/>
    <id>https://www.smallapp.xyz/2020/03/21/1.7%E8%B0%83%E8%AF%95/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:47:02.745Z</updated>
    
    <content type="html"><![CDATA[<p>虽然通常不需要这样做，但是在调试项目时，您可能希望进入ABP的源代码。<br>所有官方的ABP NuGet包是Sourcelink启用。这意味着您可以轻松地调试项目中的Abp.* NuGet包。要启用它，请更改Visual Studio(2017+)调试选项如下:<br><img src="https://raw.githubusercontent.com/aspnetboilerplate/aspnetboilerplate/master/doc/WebSite/images/enable-sourcelink.png" alt="调试"></p><p>一旦启用了它，就可以进入(F11) ABP源代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然通常不需要这样做，但是在调试项目时，您可能希望进入ABP的源代码。&lt;br&gt;所有官方的ABP NuGet包是Sourcelink启用。这意味着您可以轻松地调试项目中的Abp.* NuGet包。要启用它，请更改Visual Studio(2017+)调试选项如下:&lt;br&gt;&lt;
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>OWIN集成</title>
    <link href="https://www.smallapp.xyz/2020/03/21/1.6owin%E9%9B%86%E6%88%90/"/>
    <id>https://www.smallapp.xyz/2020/03/21/1.6owin%E9%9B%86%E6%88%90/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:46:57.585Z</updated>
    
    <content type="html"><![CDATA[<p>如果你同时使用ASP.NET MVC和ASP.NET Web API在您的应用程序中，您需要将Abp.Owin NuGet包添加到您的项目中。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将Abp.Owin NuGet包添加到您的主机项目(通常是Web项目)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Abp.Owin</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>然后在你的OWIN启动文件中调用UseAbp()扩展方法，如下图所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[assembly: OwinStartup(typeof(Startup))]</span><br><span class="line">public class Startup</span><br><span class="line">&#123;</span><br><span class="line">    public void Configuration(IAppBuilder app)</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseAbp();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;your other configuration...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您只使用OWIN(例如，在一个自托管的Web API项目中)，那么您可以使用UseAbp的覆盖，它使用一个启动模块来初始化ABP框架。注意，只有在ABP没有以另一种方式初始化的情况下才应该这样做。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你同时使用ASP.NET MVC和ASP.NET Web API在您的应用程序中，您需要将Abp.Owin NuGet包添加到您的项目中。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>启动配置</title>
    <link href="https://www.smallapp.xyz/2020/03/21/1.4%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.smallapp.xyz/2020/03/21/1.4%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:46:45.688Z</updated>
    
    <content type="html"><![CDATA[<p>ABP提供启动时配置其模块的基础结构和模型。</p><h2 id="配置ABP"><a href="#配置ABP" class="headerlink" title="配置ABP"></a>配置ABP</h2><p>在模块的预初始化方法中配置ABP。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleTaskSystemModule : AbpModule</span><br><span class="line">&#123;</span><br><span class="line">    public override void PreInitialize()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;Add languages for your application</span><br><span class="line">        Configuration.Localization.Languages.Add(new LanguageInfo(&quot;en&quot;, &quot;English&quot;, &quot;famfamfam-flag-england&quot;, true));</span><br><span class="line">        Configuration.Localization.Languages.Add(new LanguageInfo(&quot;tr&quot;, &quot;Türkçe&quot;, &quot;famfamfam-flag-tr&quot;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Add a localization source</span><br><span class="line">        Configuration.Localization.Sources.Add(</span><br><span class="line">            new XmlLocalizationSource(</span><br><span class="line">                &quot;SimpleTaskSystem&quot;,</span><br><span class="line">                HttpContext.Current.Server.MapPath(&quot;~&#x2F;Localization&#x2F;SimpleTaskSystem&quot;)</span><br><span class="line">                )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;Configure navigation&#x2F;menu</span><br><span class="line">        Configuration.Navigation.Providers.Add&lt;SimpleTaskSystemNavigationProvider&gt;();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ABP在设计时考虑了模块化。不同的模块可以配置ABP。例如，不同的模块可以添加导航提供程序来将它们自己的菜单项添加到主菜单。(有关配置的详细信息，请参阅本地化和导航文档)。</p><h2 id="取代内置的服务"><a href="#取代内置的服务" class="headerlink" title="取代内置的服务"></a>取代内置的服务</h2><p>Configuration.ReplaceService方法可用于覆盖内置服务。例如，您可以使用自定义实现替换IAbpSession服务，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration.ReplaceService&lt;IAbpSession, MySession&gt;(DependencyLifeStyle.Transient);</span><br></pre></td></tr></table></figure><p>ReplaceService方法有一个重载，它通过一个动作以自定义的方式进行替换(您可以直接使用具有高级注册API的Castle Windsor)。</p><h2 id="配置模块"><a href="#配置模块" class="headerlink" title="配置模块"></a>配置模块</h2><p>除了框架自己的启动配置外，模块还可以扩展IAbpModuleConfigurations接口来为模块提供配置点。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">using Abp.Web.Configuration;</span><br><span class="line">...</span><br><span class="line">public override void PreInitialize()</span><br><span class="line">&#123;</span><br><span class="line">    Configuration.Modules.AbpWebCommon().SendAllExceptionsToClients &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在本例中，我们将AbpWebCommon模块配置为将所有异常发送到客户端。<br>不是每个模块都应该定义这种类型的配置。当一个模块需要在不同的应用程序中重用，并且需要在启动时进行配置时，通常需要使用它。</p><h2 id="为模块创建配置"><a href="#为模块创建配置" class="headerlink" title="为模块创建配置"></a>为模块创建配置</h2><p>假设我们有一个名为MyModule的模块，它有一些配置属性。首先，我们为这些可配置的属性创建一个类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyModuleConfig</span><br><span class="line">&#123;</span><br><span class="line">    public bool SampleConfig1 &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public string SampleConfig2 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们通过依赖注入注册这个类在MyModule的PreInitialize方法上(因此，它将是可注入的):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IocManager.Register&lt;MyModuleConfig&gt;();</span><br></pre></td></tr></table></figure><p>它应该像本例中那样被注册为单例。我们现在可以使用以下代码在我们的模块的PreInitialize方法中配置MyModule:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration.Get&lt;MyModuleConfig&gt;().SampleConfig1 &#x3D; false;</span><br></pre></td></tr></table></figure><h2 id="使用扩展方法配置"><a href="#使用扩展方法配置" class="headerlink" title="使用扩展方法配置"></a>使用扩展方法配置</h2><p>我们可以使用IAbpStartupConfiguration.Get方法，可以为IModuleConfigurations创建一个扩展方法，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static class MyModuleConfigurationExtensions</span><br><span class="line">&#123;</span><br><span class="line">    public static MyModuleConfig MyModule(this IModuleConfigurations moduleConfigurations)</span><br><span class="line">    &#123;</span><br><span class="line">        return moduleConfigurations.AbpConfiguration.Get&lt;MyModuleConfig&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在其他模块可以配置这个模块使用扩展方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Configuration.Modules.MyModule().SampleConfig1 &#x3D; false;</span><br><span class="line">Configuration.Modules.MyModule().SampleConfig2 &#x3D; &quot;test&quot;;</span><br></pre></td></tr></table></figure><p>这使得研究模块配置并将其收集到单个位置(Configuration.Modules…)变得很容易。ABP本身为自己的模块配置定义了扩展方法。</p><h2 id="配置使用注入"><a href="#配置使用注入" class="headerlink" title="配置使用注入"></a>配置使用注入</h2><p>在某种程度上，MyModule需要这个配置。您可以注入MyModuleConfig并使用配置的值。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyService : ITransientDependency</span><br><span class="line">&#123;</span><br><span class="line">    private readonly MyModuleConfig _configuration;</span><br><span class="line"></span><br><span class="line">    public MyService(MyModuleConfig configuration)</span><br><span class="line">    &#123;</span><br><span class="line">        _configuration &#x3D; configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void DoIt()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_configuration.SampleConfig2 &#x3D;&#x3D; &quot;test&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，模块可以在ABP系统创建中心配置点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ABP提供启动时配置其模块的基础结构和模型。&lt;/p&gt;
&lt;h2 id=&quot;配置ABP&quot;&gt;&lt;a href=&quot;#配置ABP&quot; class=&quot;headerlink&quot; title=&quot;配置ABP&quot;&gt;&lt;/a&gt;配置ABP&lt;/h2&gt;&lt;p&gt;在模块的预初始化方法中配置ABP。例如：&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>多层架构</title>
    <link href="https://www.smallapp.xyz/2020/03/21/1.2%E5%A4%9A%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <id>https://www.smallapp.xyz/2020/03/21/1.2%E5%A4%9A%E5%B1%82%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:46:30.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>应用程序的代码分层是一个被广泛接受的技术，用来降低代码复杂性、提升重用性。为了实现分层架构，ABP遵循领域驱动设计（DDD）的准则。</p><h2 id="领取驱动设计分层"><a href="#领取驱动设计分层" class="headerlink" title="领取驱动设计分层"></a>领取驱动设计分层</h2><p>在DDD中，有四层基本结构：<br><strong>表现层</strong>：提供用户访问接口。使用应用层来实现用户的命令。<br><strong>应用层</strong>:在表现层和领域层中间传达信息。编排业务对象来实现特殊的应用任务。<br><strong>领域层</strong>:包括业务对象和规则。是应用的核心。<br><strong>基础设施层</strong>：提供基础技术支持，主要使用第三方库来支持更高层的调用。</p><h2 id="ABP应用结构模型"><a href="#ABP应用结构模型" class="headerlink" title="ABP应用结构模型"></a>ABP应用结构模型</h2><p>在一个现代程序架构中，除了DDD之外，也应有其他的逻辑层的和物理层。推荐在ABP的应用程序中，使用下面的模型。ABP通过提供基础class和服务，更为轻便地实现这些模型。同样提供了<a href="https://aspnetboilerplate.com/Templates" target="_blank" rel="noopener">启动模板</a>，来直接使用这些模型。<br><img src="https://raw.githubusercontent.com/aspnetboilerplate/aspnetboilerplate/master/doc/WebSite/images/abp-nlayer-architecture.png" alt="结构模型"></p><h2 id="客户端应用"><a href="#客户端应用" class="headerlink" title="客户端应用"></a>客户端应用</h2><p>有远程客户端通过调用HTTP结构，使用应用作为客户端的远程服务。一个远程客户端可以是单页面应用，可以是移动端应用，或者是第三方消费。本地化和导航可以部署在这些应用中。</p><h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><p>ASP.NET [Core] MVC (Model-View-Controller)可以被看作是一个物理层(通过调用API使用应用)或者是一个逻辑层(直接注入和使用应用服务)。两种情况都可以部署本地化、导航、对象映射、缓存、配置管理、日志审计等等。也包括处理验证、会话存储、对象特征和异常处理。</p><h2 id="服务分发层"><a href="#服务分发层" class="headerlink" title="服务分发层"></a>服务分发层</h2><p>该层结构通过应用远程API如REST、OData、GraphQL等提供应用/服务功能。这不包括业务逻辑，仅仅是把HTTP请求转换为对领域数据的访问，或者使用应用服务来委托操作。该层通常包括验证、缓存、日志审计、对象映射、异常处理、会话存储等功能。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层主要包括使用领域层对象及方法来实现应用请求的<strong>应用服务</strong>。使用数据传输对象来获取数据，并把数据返回给表示层或者分布式服务层。它还可以处理授权、缓存、审计日志记录、对象映射、会话等等……</p><h2 id="领域层"><a href="#领域层" class="headerlink" title="领域层"></a>领域层</h2><p>这是实现域逻辑的主层。包括实体、值对象、领域服务来执行业务/域逻辑。它还可以包括规范和触发域事件。它定义了用于从数据源读取和持久化实体的存储库接口。</p><h2 id="基础设施层"><a href="#基础设施层" class="headerlink" title="基础设施层"></a>基础设施层</h2><p>基础设施层为其它层提供保障：它直接跟数据库交互，从而实现了存储库接口(使用Entity Framework Core)。它还可能集成了发送邮件的方式等等。这并不是所有层下面的严格层，而是通过实现其他层的抽象概念来支持它们。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;应用程序的代码分层是一个被广泛接受的技术，用来降低代码复杂性、提升重用性。为了实现分层架构，ABP遵循领域驱动设计（DDD）的准则。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>Session</title>
    <link href="https://www.smallapp.xyz/2020/03/21/2.2session/"/>
    <id>https://www.smallapp.xyz/2020/03/21/2.2session/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:47:12.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>ABP提供了IAbpSession接口来获取当前用户和租户，而不需要使用ASP.NET的会话。在ABP中，IAbpSession也被其他结构完全集成和使用，如<a href="https://aspnetboilerplate.com/Pages/Documents/Setting-Management" target="_blank" rel="noopener">设置</a>和<a href="https://aspnetboilerplate.com/Pages/Documents/Authorization" target="_blank" rel="noopener">授权系统</a>。</p><h2 id="注入会话"><a href="#注入会话" class="headerlink" title="注入会话"></a>注入会话</h2><p>IAbpSession通常是注入到需要的类中的属性，除非没有会话信息就无法工作。如果我们使用属性注入，我们可以使用NullAbpSession.Instance作为默认值，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass : ITransientDependency</span><br><span class="line">&#123;</span><br><span class="line">    public IAbpSession AbpSession &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        AbpSession &#x3D; NullAbpSession.Instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void MyMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        var currentUserId &#x3D; AbpSession.UserId;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于身份验证/授权是一个应用层任务，在应用层和上层使用IAbpSession是明智之举。这通常不是在域层中完成的。ApplicationService、AbpController、AbpApiController和其他一些基类已经注入了AbpSession，因此，例如，您可以直接在应用程序服务方法中使用AbpSession属性。</p><h2 id="会话属性"><a href="#会话属性" class="headerlink" title="会话属性"></a>会话属性</h2><p>AbpSession定义了几个关键属性:</p><ul><li><strong>UserId</strong>: 当前用户的Id，如果没有当前用户则为null。如果需要调用授权代码，则不能为空。</li><li><strong>TenantId</strong>: 当前租户的Id，如果没有当前租户，则为null(如果用户没有登录或他是主机用户)。</li><li><strong>ImpersonatorUserId</strong>: 如果当前会话由另一个用户模拟，则为该模拟用户的Id。如果这不是模拟登录，则为空。</li><li><strong>ImpersonatorTenantId</strong>: 如果当前会话由另一个用户模拟，则该模拟用户的租户的Id。如果这不是模拟登录，则为空。</li><li><strong>MultiTenancySide</strong>: 它可以是主机或租户。</li></ul><p><strong>UserId</strong>和<strong>TenantId</strong>是可空的。还有不可空的<strong>GetUserId()</strong>和<strong>GetTenantId()</strong>方法。如果确定有当前用户，可以调用<strong>GetUserId()</strong>。如果当前用户为空，则此方法将引发异常。<strong>GetTenantId()</strong>也以这种方式工作。</p><p>模拟程序属性不像其他属性那样常见，通常用于审计日志记录。</p><h3 id="ClaimsAbpSession"><a href="#ClaimsAbpSession" class="headerlink" title="ClaimsAbpSession"></a>ClaimsAbpSession</h3><p>ClaimsAbpSession是IAbpSession接口的默认实现。它从当前用户的主体声明中获取会话属性(MultiTenancySide除外,it’s calculated)。对于基于cookie的表单身份验证，它从cookie获取值。因此，它完全集成到 ASP.NET’s的身份验证机制。</p><h2 id="覆盖当前会话值"><a href="#覆盖当前会话值" class="headerlink" title="覆盖当前会话值"></a>覆盖当前会话值</h2><p>在某些特定情况下，您可能需要更改/覆盖有限范围内的会话值。在这种情况下，您可以使用IAbpSession.Use方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyService</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IAbpSession _session;</span><br><span class="line"></span><br><span class="line">    public MyService(IAbpSession session)</span><br><span class="line">    &#123;</span><br><span class="line">        _session &#x3D; session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Test()</span><br><span class="line">    &#123;</span><br><span class="line">        using (_session.Use(42, null))</span><br><span class="line">        &#123;</span><br><span class="line">            var tenantId &#x3D; _session.TenantId; &#x2F;&#x2F;42</span><br><span class="line">            var userId &#x3D; _session.UserId; &#x2F;&#x2F;null</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Use方法返回一个IDisposable，它必须被释放。一旦返回值被释放，会话值将自动恢复到以前的值。</p><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning!"></a>Warning!</h2><p>始终在using块中使用use方法，如上所示。否则，您可能会得到意外的会话值。您可以嵌套使用块，它们将如您所期望的那样工作。</p><h2 id="用户识别"><a href="#用户识别" class="headerlink" title="用户识别"></a>用户识别</h2><p>您可以使用 .touseridentifier()扩展方法从IAbpSession创建一个UserIdentifier对象。由于UserIdentifier在许多api中都被使用，这将简化当前用户UserIdentifier对象的创建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;ABP提供了IAbpSession接口来获取当前用户和租户，而不需要使用ASP.NET的会话。在ABP中，IAbpSession也被其他结构
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>什么是ABP(ASP.NET Boilerplate)</title>
    <link href="https://www.smallapp.xyz/2020/03/21/1.1%E4%BB%80%E4%B9%88%E6%98%AFABP/"/>
    <id>https://www.smallapp.xyz/2020/03/21/1.1%E4%BB%80%E4%B9%88%E6%98%AFABP/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:46:22.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-the-ASP-NET-Boilerplate"><a href="#What-is-the-ASP-NET-Boilerplate" class="headerlink" title="What is the ASP.NET Boilerplate?"></a>What is the ASP.NET Boilerplate?</h2><p>ASP.NET Boilerplate (ABP) 是一个开源的、具有完善说明文档的应用架构.它不只是一个架构，它同样提供了一类强大的基于领取驱动设计的、结合作者最佳实践的结构模型。</p><p>ABP支持使用最新的 ASP.NET Core &amp; EF Core,亦支持ASP.NET MVC 5.x &amp; EF 6.x.</p><h2 id="A-Quick-Sample"><a href="#A-Quick-Sample" class="headerlink" title="A Quick Sample"></a>A Quick Sample</h2><p>让我们通过一个简单的示例来看看ABP的优点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TaskAppService : ApplicationService, ITaskAppService</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IRepository&lt;Task&gt; _taskRepository;</span><br><span class="line"></span><br><span class="line">    public TaskAppService(IRepository&lt;Task&gt; taskRepository)</span><br><span class="line">    &#123;</span><br><span class="line">        _taskRepository &#x3D; taskRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [AbpAuthorize(MyPermissions.UpdateTasks)]</span><br><span class="line">    public async Task UpdateTask(UpdateTaskInput input)</span><br><span class="line">    &#123;</span><br><span class="line">        Logger.Info(&quot;Updating a task for input: &quot; + input);</span><br><span class="line"></span><br><span class="line">        var task &#x3D; await _taskRepository.FirstOrDefaultAsync(input.TaskId);</span><br><span class="line">        if (task &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new UserFriendlyException(L(&quot;CouldNotFindTheTaskMessage&quot;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ObjectMapper.MapTo(input, task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一个简单的应用服务方法。在领域驱动模式中，一个应用服务可以直接被表现层调用，来实现应用功能。把 <strong>UpdateTask</strong> 想做一个能够被JS或者Ajax调用的方法。</p><p>让我们来看一下ABP的优点：</p><ul><li><p><strong>依赖注入</strong>：ABP使用并提供传统的依赖注入的方式。因为上述class是一个应用服务(Application Service)，他被短时间内注入到容器中。这可以轻松实现注入和依赖(例如示例中的 IRepository<Task> )。</p></li><li><p><strong>仓储</strong>:ABP可以为每个实体建立一个仓库(例如示例中的IRepository<Task>)。默认仓库中有许多有用的方法，例如示例中的FirstOrDefault。我们可以扩展默认的仓库来适应我们的需求。仓库抽象了DBMS和ORMs，简化了数据访问逻辑。</p></li><li><p><strong>授权</strong>:ABP能够声明式的检查权限。这可以防止没有update tasks权限或者没有登录的用户访问UpdateTask方法。ABP不只可以使用声明式的特性(Attribute)，还有其他的授权方式。</p></li><li><p><strong>验证</strong>:ABP自动检查输入是否为null。它也会根据用户自定义的验证规则或者标准注释特性，来检查输入的内容。如果请求未通过，会抛出对应的验证异常，可在客户端处理。</p></li><li><p><strong>审计日志</strong>:每一个用户请求，都会按照惯例或者基于用户配置，自动的保存对应信息。包括但不限于：用户、浏览器、IP地址、请求服务、方法、参数、请求时间、执行时间还有一些其他的信息。</p></li><li><p><strong>工作单元</strong>:在ABP中，每一个应用服务中的方法，默认都会被设定为一个工作单元。这会自动的建立连接，并且在方法开始使用之前，开启一个事务。如果方法成功的完成，并且未抛出异常。那么事务就会被提交，连接释放。即使此方法中使用不同的仓库或者方法，他们亦是原子结构的(事务性)。实体的所有改动会在事务提交的时候自动保存。正如上例所说，我们根本不需要调用_repository.Update(task)(更新实体方法)即可完成修改.</p></li><li><p><strong>异常处理</strong>:使用ABP的web应用中，我们几乎不用手动处理异常。所有的异常默认自动被处理。当一个异常抛出时，ABP自动将其记录到日志，并且返回一个适当的结果到客户端。例如，如果这是一个AJAX请求，它返回一个json对象到客户端，告诉客户端产生了一个错误。它对客户端隐藏了实际的异常信息，除非如例子中所示，此异常是一个UserFriendlyException。它也理解并处理来自客户端的异常，对用户显示适当的信息。</p></li><li><p><strong>日志</strong>:如你所见，我们可以使用在基础class中定义的Logger对象来记录日志。日志组件默认使用的是Log4Net，这是可配置和替换的。</p></li><li><p><strong>多语言(本地化)</strong>：是否注意到我们在抛出异常的时候，使用了’L’方法？通过这个方法，基于用户的文化自动的进行本地化（多语言切换）。想要了解更多请查看本地化文档。</p></li><li><p><strong>自动映射</strong>：在方法的末尾，我们使用ABP的IObjectMapper类中的MapTo方法，映射输入。从一个实体属性到另一个实体的属性。这使用了AutoMapper库来实现映射。我们可以基于命名规则，轻松地映射一个对象的属性到另一个对象中。</p></li><li><p><strong>动态API层</strong>:事实上TaskAppService是一个简单的class。我们通常封装一个API Controller来把方法提供给JS客户端，但是ABP在运行时自动的做到了这一部分。用这种方式，我么你可以直接在客户端调用应用服务中的方法。</p></li><li><p><strong>动态JS AJAX Proxy</strong>:ABP建立了代理方法，使得在在客户端调用应用服务方法，像在客户端调用JS方法一样方便。<br>我们可以通过示例看到ABP的优点。通常这些工作会占用大量时间，但是框架自动处理他们。<br>除了这个简单的示例之外，ABP提供了一个强大的基础设施和开发模式，包括模块化、多租户、缓存、后台任务、数据过滤、设置管理、领域事件、单元测试&amp;集成测试等等…你要做的就是专注于业务代码而非重复工作。</p></li></ul><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>你可以从启动模板和教程介绍开始</p><h2 id="启动模板"><a href="#启动模板" class="headerlink" title="启动模板"></a>启动模板</h2><p>直接使用启动模板创建一个具有时尚外观的启动项目<br><img src="https://raw.githubusercontent.com/aspnetboilerplate/aspnetboilerplate/master/doc/WebSite/images/module-zero-core-template-ui-home.png" alt="示例"></p><p>启动模板提供了一个基础的布局和一些应用常见功能。有多个<a href="https://aspnetboilerplate.com/Pages/Documents" target="_blank" rel="noopener">启动模板</a>可供选择。</p><h2 id="说明文档"><a href="#说明文档" class="headerlink" title="说明文档"></a>说明文档</h2><p>教程介绍了框架，并解释了如何创建您的应用程序基于启动模板</p><h2 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h2><p>Use the <a href="https://github.com/aspnetboilerplate/aspnetboilerplate" target="_blank" rel="noopener">GitHub repository</a> to access the latest source code, create issues and send pull requests.<br>Use <a href="https://stackoverflow.com/questions/tagged/aspnetboilerplate" target="_blank" rel="noopener">aspnetboilerplate tag</a> on stackoverflow to ask questions about the usage.<br>Follow <a href="https://twitter.com/aspboilerplate" target="_blank" rel="noopener">aspboilerplate</a> on twitter to be informed about the happenings.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;What-is-the-ASP-NET-Boilerplate&quot;&gt;&lt;a href=&quot;#What-is-the-ASP-NET-Boilerplate&quot; class=&quot;headerlink&quot; title=&quot;What is the ASP.NET Boilerplat
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>多租户</title>
    <link href="https://www.smallapp.xyz/2020/03/21/1.5%E5%A4%9A%E7%A7%9F%E6%88%B7/"/>
    <id>https://www.smallapp.xyz/2020/03/21/1.5%E5%A4%9A%E7%A7%9F%E6%88%B7/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:46:51.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是多租户"><a href="#什么是多租户" class="headerlink" title="什么是多租户"></a>什么是多租户</h2><p>软件多租户指的是一种软件架构，其中一个软件实例运行在服务器上，为多个租户服务。租户是一组用户，他们共享对软件实例具有特定特权的公共访问。使用多租户体系结构，软件应用程序被设计为为每个租户提供一个专用的实例共享，包括其数据、配置、用户管理、租户个人功能和非功能性属性。多租户与多实例体系结构形成对比，在多实例体系结构中，独立的软件实例代表不同的租户进行操作。<br>简而言之，多租户是一项创建SAAS(Software as-a Service)应用的服务。</p><h2 id="数据库和部署架构"><a href="#数据库和部署架构" class="headerlink" title="数据库和部署架构"></a>数据库和部署架构</h2><p>有一些不同的多租户数据库和部署方法：</p><h3 id="多个部署——多个数据库"><a href="#多个部署——多个数据库" class="headerlink" title="多个部署——多个数据库"></a>多个部署——多个数据库</h3><p>这实际上不是多租户，但是如果我们使用一个独立的数据库为每个客户(租户)运行一个应用程序实例，我们可以在一个服务器上为多个租户提供服务。我们只需确保应用程序的多个实例在相同的服务器环境中不会相互冲突。<br>对于设计为非多租户的现有应用程序，这也是可能的。创建这样的应用程序比较容易，因为应用程序不知道多租户。但是，这种方法存在设置、使用和维护问题。</p><h3 id="单一部署—多个数据库"><a href="#单一部署—多个数据库" class="headerlink" title="单一部署—多个数据库"></a>单一部署—多个数据库</h3><p>在这种方法中，我们在服务器上运行应用程序的单个实例。我们有一个主(主机)数据库来存储租户元数据(如租户名称和子域)，并为每个租户提供一个单独的数据库。一旦我们确定了当前的租户(例如，从子域或从用户登录表单),然后，我们可以切换到该租户的数据库来执行操作。<br>我们为每个租户创建和维护一个单独的数据库，这包括数据库迁移。如果我们有许多使用专用数据库的客户，那么在应用程序更新期间迁移数据库模式可能需要很长时间。由于每个承租者都有一个单独的数据库，所以可以将其数据库与其他承租者分开备份。如果租户需要，我们还可以将租户数据库移动到更强大的服务器上。</p><h3 id="单一部署——单一数据库"><a href="#单一部署——单一数据库" class="headerlink" title="单一部署——单一数据库"></a>单一部署——单一数据库</h3><p>这是最理想的多租户体系结构:我们只将应用程序的单个实例与单个数据库部署到单个服务器上。每个表(对于RDBMS)中都有一个TenantId(或类似的)字段，用于将租户的数据与其他数据隔离。<br>这种类型的应用程序易于设置和维护，但难于创建。这是因为我们必须防止租户读取或写入其他租户数据。我们可以为每个数据库读(选择)操作添加一个TenantId过滤器。我们也可以在每次写入时检查它，看看这个实体是否与当前租户相关。这很乏味，而且容易出错。然而,ASP。NET Boilerplate通过使用自动数据过滤来帮助我们。<br>如果有许多租户使用大型数据集，则此方法可能会出现性能问题。我们可以使用表分区或其他数据库特性来克服这个问题。</p><h3 id="单一部署——混合数据库"><a href="#单一部署——混合数据库" class="headerlink" title="单一部署——混合数据库"></a>单一部署——混合数据库</h3><p>通常，我们可能希望将租户存储在单个数据库中，但是可能希望为所需的租户创建一个单独的数据库。例如，我们可以将拥有大数据的租户存储在他们自己的数据库中，而将所有其他租户存储在一个数据库中。</p><h3 id="多部署——单个-多个-混合数据库"><a href="#多部署——单个-多个-混合数据库" class="headerlink" title="多部署——单个/多个/混合数据库"></a>多部署——单个/多个/混合数据库</h3><p>最后，我们可能希望将应用程序部署到多个服务器(如web farm)，以获得更好的应用程序性能、高可用性和/或可伸缩性。这与数据库方法无关。</p><h2 id="ABP中的多租户"><a href="#ABP中的多租户" class="headerlink" title="ABP中的多租户"></a>ABP中的多租户</h2><p>ABP可以处理上面描述的所有场景。</p><h3 id="启用多租户"><a href="#启用多租户" class="headerlink" title="启用多租户"></a>启用多租户</h3><p>框架级别默认禁用多租户。我们可以在模块的PreInitialize method中启用它，如下图所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration.MultiTenancy.IsEnabled &#x3D; true;</span><br></pre></td></tr></table></figure><h3 id="忽略主机用户的特性检查"><a href="#忽略主机用户的特性检查" class="headerlink" title="忽略主机用户的特性检查"></a>忽略主机用户的特性检查</h3><p>还有一种配置可以忽略主机用户的特性检查。我们可以在模块的PreInitialize method中启用它，如下图所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration.MultiTenancy.IgnoreFeatureCheckForHostUsers &#x3D; true;</span><br></pre></td></tr></table></figure><h2 id="主机vs租户"><a href="#主机vs租户" class="headerlink" title="主机vs租户"></a>主机vs租户</h2><p>我们定义了在多租户系统中使用的两个术语:</p><ul><li>Tenant:有自己的用户、角色、权限、设置……并使用与其他租户完全隔离的应用程序。多租户应用程序将有一个或多个租户。如果这是一个CRM应用程序，不同的租户也有自己的帐户、联系人、产品和订单。所以当我们说“承租者用户”时，我们指的是承租者拥有的用户。</li><li>Host: 主机是单例的(只有一个主机)。主机负责创建和管理租户。“主机用户”位于更高的级别，独立于所有租户，可以控制它们。<h2 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session(会话)"></a>Session(会话)</h2>ABP定义了IAbpSession接口来获取当前用户和租户id。默认情况下，此接口用于多租户以获取当前租户的id。因此，它可以根据当前租户的id过滤数据。</li><li>如果UserId和TenantId都为空，则当前用户没有登录到系统。我们无法知道它是主机用户还是租户用户。在这种情况下，用户不能访问授权的内容。</li><li>如果UserId不为空，TenantId为空，那么我们知道当前用户是主机用户。</li><li>如果UserId不为空，TenantId也不为空，我们就知道当前用户是租户用户。</li><li>如果UserId为null，但TenantId不为null，这意味着我们知道当前租户，但当前请求未被授权(用户未登录)。请参阅下一节以了解如何确定当前租户。</li></ul><p>有关<a href="https://aspnetboilerplate.com/Pages/Documents/Abp-Session" target="_blank" rel="noopener">更多信息</a>，请参见会话文档。</p><h2 id="确定当前租户"><a href="#确定当前租户" class="headerlink" title="确定当前租户"></a>确定当前租户</h2><p>由于所有租户用户都使用相同的应用程序，所以我们应该有一种方法来区分当前请求的租户。默认的会话实现(ClaimsAbpSession)使用不同的方法来找到与当前请求相关的租户，顺序如下:</p><ol><li>如果用户已登录，它将从当前声明(claim)中获取TenantId。声明(claim)名称是<a href="http://www.aspnetboilerplate.com/identity/claims/tenantId，应该包含一个整数值。如果在声明中没有找到该用户，则假定该用户是主机用户。" target="_blank" rel="noopener">http://www.aspnetboilerplate.com/identity/claims/tenantId，应该包含一个整数值。如果在声明中没有找到该用户，则假定该用户是主机用户。</a></li><li>如果用户尚未登录，则它将尝试从tenant resolve contributors解析TenantId。有3个预定义的租户贡献者，并以一个给定的顺序(第一个成功解析器’wins ‘)运行:<ol><li>DomainTenantResolveContributor: 尝试从url解析租赁名称，通常是从域或子域解析。您可以在模块的PreInitialize方法中配置域格式(如Configuration.Modules.AbpWebCommon().MultiTenancy.DomainFormat = “{0}.mydomain.com”;)。如果域格式是“{0}.mydomain.com”，而请求的当前主机是acme.mydomain.com，则租赁权名称解析为“acme”。下一步是查询ITenantStore，根据给定的租户名称查找TenantId。如果找到租户，则将其解析为当前租户。<ol start="2"><li>HttpHeaderTenantResolveContributor: 如果存在，尝试从“Abp.TenantId”header值解析TenantId。这是在Abp.MultiTenancy.MultiTenancyConsts.TenantIdResolveKey中定义的一个常数。</li><li>HttpCookieTenantResolveContributor: 如果存在，尝试从“Abp.TenantId”cookie值解析TenantId。这里使用的是与上面介绍的相同的常数。<br>默认情况下,ABP使用“Abp.TenantId”来从Cookie或请求头文件中查找TenantId。你可以使用多租户配置来更改:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configuration.MultiTenancy.TenantIdResolveKey &#x3D; &quot;Abp-TenantId&quot;;</span><br></pre></td></tr></table></figure>你还需要在客户端配置它:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abp.multiTenancy.tenantIdCookieName &#x3D; &#39;Abp-TenantId&#39;;</span><br></pre></td></tr></table></figure>如果这些尝试都不能解析TenantId，则认为当前请求者是主机。租户解析器是可扩展的。您可以向Configuration.MultiTenancy.Resolvers集合添加解析器，或删除现有的解析器。<br>关于解析器的最后一件事：出于性能原因，在同一请求期间缓存已解析的租户id。解析器在请求中执行一次，并且仅在当前用户尚未登录时执行。</li></ol></li></ol></li></ol><h2 id="租户存储"><a href="#租户存储" class="headerlink" title="租户存储"></a>租户存储</h2><p>DomainTenantResolveContributor使用ITenantStore根据租户名称查找租户id。ITenantStore的默认实现是NullTenantStore，它不包含任何租户，查询时返回null。您可以实现并替换它来从任何数据源查询租户。模块Zero通过从它的租户管理器获得它，从而正确地实现了它。因此，如果使用模块Zero，就不必担心租户存储。</p><h2 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h2><p>对于多租户单数据库方法，我们必须添加TenantId过滤器，以便在从数据库检索实体时仅获取当前租户的实体。当您为您的实体实现两个接口之一:IMustHaveTenant和IMayHaveTenant时，ABP将自动执行此操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Product : Entity, IMustHaveTenant</span><br><span class="line">&#123;</span><br><span class="line">    public int TenantId &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...other properties</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式,ABP知道这是一个特定于租户的实体，并自动将租户的实体与其他租户隔离开来。</p><h2 id="IMayHaveTenant接口"><a href="#IMayHaveTenant接口" class="headerlink" title="IMayHaveTenant接口"></a>IMayHaveTenant接口</h2><p>我们可能需要在主机和租户之间共享一个实体类型。因此，一个实体可以由租户或主机拥有。IMayHaveTenant接口也定义了TenantId(类似于IMustHaveTenant)，但是在本例中它是可空的。实现IMayHaveTenant的示例实体:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Role : Entity, IMayHaveTenant</span><br><span class="line">&#123;</span><br><span class="line">    public int? TenantId &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public string RoleName &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...other properties</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用相同的角色类来存储主机角色和租户角色。在本例中，TenantId属性表示这是主机实体还是租户实体。空值意味着这是一个主机实体，非空值意味着这个实体由租户所有，而Id是TenantId。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>IMayHaveTenant并不像IMustHaveTenant一样常见。例如，产品类不能是IMayHaveTenant，因为产品与实际的应用程序功能相关，而与管理承租者无关。所以要小心使用IMayHaveTenant接口，因为维护主机和租户共享的代码比较困难。<br>当你定义一个实体类型为IMustHaveTenant或IMayHaveTenant时，要在你创建一个新的实体时设置TenantId(然而ABP试图从当前TenantId设置它，在某些情况下可能不可能，特别是对于IMayHaveTenant实体)。大多数情况下，这是你处理TenantId属性的唯一时刻。在编写LINQ时，不需要在条件中显式地编写TenantId过滤器，因为它是自动过滤的。</p><h2 id="在主机和租户之间切换"><a href="#在主机和租户之间切换" class="headerlink" title="在主机和租户之间切换"></a>在主机和租户之间切换</h2><p>在处理多租户应用程序数据库时，我们可以获得当前租户。默认情况下，它是从IAbpSession中获得的(如前所述)。我们可以更改此行为并切换到另一个租户的数据库。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ProductService : ITransientDependency</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IRepository&lt;Product&gt; _productRepository;</span><br><span class="line">    private readonly IUnitOfWorkManager _unitOfWorkManager;</span><br><span class="line"></span><br><span class="line">    public ProductService(IRepository&lt;Product&gt; productRepository, IUnitOfWorkManager unitOfWorkManager)</span><br><span class="line">    &#123;</span><br><span class="line">        _productRepository &#x3D; productRepository;</span><br><span class="line">        _unitOfWorkManager &#x3D; unitOfWorkManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [UnitOfWork]</span><br><span class="line">    public virtual List&lt;Product&gt; GetProducts(int tenantId)</span><br><span class="line">    &#123;</span><br><span class="line">        using (_unitOfWorkManager.Current.SetTenantId(tenantId))</span><br><span class="line">        &#123;</span><br><span class="line">            return _productRepository.GetAllList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SetTenantId确保我们处理的是给定租户的数据，独立于数据库架构:</p><ul><li>如果给定的租户有一个专用的数据库，它将切换到该数据库并从中获取产品。</li><li>如果给定的租户没有专用的数据库(例如，单一数据库方法)，则添加自动TenantId筛选器来只查询该租户的产品。<br>如果我们不使用SetTenantId，它会从session获取tenantId。这里有一些指导方针和最佳实践:</li><li>使用SetTenantId(null)切换到主机。</li><li>如果没有特殊情况，请在using块中使用SetTenantId(如本例中所示)。通过这种方式，它会在using块的末尾自动恢复tenantId，并且调用GetProducts方法的代码与前面一样工作。</li><li>如果需要，可以在嵌套块中使用SetTenantId。</li><li>因为_unitOfWorkManager.Current仅在工作单元中可用，请确保您的代码在UOW中运行。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是多租户&quot;&gt;&lt;a href=&quot;#什么是多租户&quot; class=&quot;headerlink&quot; title=&quot;什么是多租户&quot;&gt;&lt;/a&gt;什么是多租户&lt;/h2&gt;&lt;p&gt;软件多租户指的是一种软件架构，其中一个软件实例运行在服务器上，为多个租户服务。租户是一组用户，他们共享对软件
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
  <entry>
    <title>缓存</title>
    <link href="https://www.smallapp.xyz/2020/03/21/2.3%E7%BC%93%E5%AD%98/"/>
    <id>https://www.smallapp.xyz/2020/03/21/2.3%E7%BC%93%E5%AD%98/</id>
    <published>2020-03-20T16:00:00.000Z</published>
    <updated>2020-04-02T05:47:22.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>ABP提供了缓存的抽象。它在内部使用这个缓存抽象。虽然默认实现使用了MemoryCache，但它可以被实现并与任何其他缓存提供程序交换。例如，Abp.RedisCache包使用Redis实现缓存(参见下面的“Redis缓存集成”一节)。</p><h2 id="ICacheManager"><a href="#ICacheManager" class="headerlink" title="ICacheManager"></a>ICacheManager</h2><p>缓存的主要接口是ICacheManager。我们可以注入它并使用它来获得缓存。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestAppService : ApplicationService</span><br><span class="line">&#123;</span><br><span class="line">    private readonly ICacheManager _cacheManager;</span><br><span class="line"></span><br><span class="line">    public TestAppService(ICacheManager cacheManager)</span><br><span class="line">    &#123;</span><br><span class="line">        _cacheManager &#x3D; cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Item GetItem(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;Try to get from cache</span><br><span class="line">        return _cacheManager</span><br><span class="line">                .GetCache(&quot;MyCache&quot;)</span><br><span class="line">                .Get(id.ToString(), () &#x3D;&gt; GetFromDatabase(id)) as Item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Item GetFromDatabase(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;... retrieve item from database</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，我们将注入ICacheManager并获得一个名为MyCache的缓存。缓存名是大小写敏感的，这意味着“MyCache”和“MyCache”是两个不同的缓存</p><h2 id="ICache"><a href="#ICache" class="headerlink" title="ICache"></a>ICache</h2><p>ICacheManager.GetCache方法返回一个ICache。缓存是单例的(每个缓存名)。它是在第一次请求时创建的，然后总是返回相同的缓存对象。通过这种方式，我们可以在不同的类(客户端)中使用相同的名称共享相同的缓存。</p><p>在示例代码中，我们看到了ICache的一个简单用法ICache.Get方法。它有两个参数:</p><ul><li>key: 缓存中一项的唯一键(字符串).</li><li>factory: 如果没有具有给定键的项，则调用该操作。工厂方法应该创建并返回实际的项目。如果给定的键存在于缓存中，则不调用它。</li></ul><p>ICache接口还有GetOrDefault、Set、Remove和Clear等方法。所有方法都有异步版本。</p><h2 id="ITypedCache"><a href="#ITypedCache" class="headerlink" title="ITypedCache"></a>ITypedCache</h2><p>ICache接口使用一个字符串作为键，一个对象作为值。ITypedCache是ICache的一个包装器，提供了一个类型安全的通用缓存。我们可以使用通用的GetCache扩展方法来获得一个ITypedCache:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITypedCache&lt;int, Item&gt; myCache &#x3D; _cacheManager.GetCache&lt;int, Item&gt;(&quot;MyCache&quot;);</span><br></pre></td></tr></table></figure><p>我们还可以使用AsTyped扩展方法将现有的ICache实例转换为ITypedCache。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>默认的缓存过期时间是60分钟。它在滑动，所以如果你不在缓存中使用一个项目60分钟，它会自动从缓存中删除。您可以为所有缓存或特定的缓存配置它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Configuration for all caches</span><br><span class="line">Configuration.Caching.ConfigureAll(cache &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cache.DefaultSlidingExpireTime &#x3D; TimeSpan.FromHours(2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Configuration for a specific cache</span><br><span class="line">Configuration.Caching.Configure(&quot;MyCache&quot;, cache &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    cache.DefaultSlidingExpireTime &#x3D; TimeSpan.FromHours(8);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码应该放在模块的PreInitialize方法中。使用此代码，“MyCache”将在8小时内过期，而所有其他缓存项将在2小时内过期。</p><p>一旦缓存首次创建(在第一次请求时)，就会调用配置操作。配置不局限于DefaultSlidingExpireTime，因为缓存对象是一个ICacheOptions，您可以使用它的属性自由地配置和初始化它。</p><h2 id="Entity-Caching"><a href="#Entity-Caching" class="headerlink" title="Entity Caching"></a>Entity Caching</h2><p>虽然ABP的缓存系统是为一般用途。但如果你想缓存实体，有一个EntityCache基类，可以帮助你。如果我们通过实体的Id来获取实体，并且我们希望通过Id来缓存它们，那么我们可以使用这个基类，这样就不会重复查询数据库。假设我们有一个这样的Person实体:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person : Entity</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public int Age &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设当我们知道他们的Id，我们经常想要获得人名。首先，我们创建一个类来存储缓存项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[AutoMapFrom(typeof(Person))]</span><br><span class="line">public class PersonCacheItem</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要直接在缓存中存储实体，因为缓存可能需要序列化缓存的对象。实体可能不会被序列化，特别是当它们具有导航属性时。这就是为什么我们定义了一个简单的(DTO)类来在缓存中存储数据。我们添加了AutoMapFrom属性，因为我们希望使用AutoMapper将Person实体自动转换为PersonCacheItem对象。如果我们不使用AutoMapper，我们应该覆盖EntityCache类的MapToCacheItem方法来手动转换/映射它。<br>虽然这不是必需的，我们可能想要为我们的缓存类定义一个接口:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IPersonCache : IEntityCache&lt;PersonCacheItem&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以创建cache类来缓存Person实体:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PersonCache : EntityCache&lt;Person, PersonCacheItem&gt;, IPersonCache, ITransientDependency</span><br><span class="line">&#123;</span><br><span class="line">    public PersonCache(ICacheManager cacheManager, IRepository&lt;Person&gt; repository)</span><br><span class="line">        : base(cacheManager, repository)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样。我们的人员缓存准备使用! 缓存类可以是瞬态的(如本例所示)，也可以是单例的。这并不意味着缓存的数据是暂时的。它总是全局缓存，并在应用程序中以线程安全的方式访问。<br>无论何时我们需要一个人的名字，我们都可以通过使用这个人的Id从缓存中获得它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyPersonService : ITransientDependency</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IPersonCache _personCache;</span><br><span class="line"></span><br><span class="line">    public MyPersonService(IPersonCache personCache)</span><br><span class="line">    &#123;</span><br><span class="line">        _personCache &#x3D; personCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public string GetPersonNameById(int id)</span><br><span class="line">    &#123;</span><br><span class="line">        return _personCache[id].Name; &#x2F;&#x2F;alternative: _personCache.Get(id).Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需注入IPersonCache，获取缓存项，然后获取Name属性。</p><h2 id="How-EntityCache-Works"><a href="#How-EntityCache-Works" class="headerlink" title="How EntityCache Works"></a>How EntityCache Works</h2><ul><li>它在第一次调用时从存储库(数据库)获取实体。然后在后续调用中从缓存中获取。</li><li>如果更新或删除缓存的实体，它将自动使其无效。因此，它将在下一个调用中从数据库中检索。</li><li>它使用IObjectMapper将实体映射到缓存项。IObjectMapper是由AutoMapper模块实现的。如果您正在使用AutoMapper模块，则需要它。您可以覆盖MapToCacheItem方法来手动将实体映射到缓存项。</li><li>它使用cache类的FullName作为缓存名。您可以通过将缓存名传递给基本构造函数来更改它。</li><li>它是线程安全的。<br>如果需要更复杂的缓存需求，可以扩展EntityCache或创建自己的解决方案。</li></ul><h2 id="Multi-Tenancy-Entity-Caching"><a href="#Multi-Tenancy-Entity-Caching" class="headerlink" title="Multi-Tenancy Entity Caching"></a>Multi-Tenancy Entity Caching</h2><p>虽然EntityCache可以帮助您缓存实体，但它不是多租户安全的。例如，由承租者A检索和缓存的实体不应该被承租者b缓存。为了正确缓存多租户实体，我们引入了MustHaveTenantEntityCache和MayHaveTenantEntityCache，它们接受实现IMustHaveTenant或IMayHaveTenant接口的实体类<br>类似于实体缓存，我们可以有IMayHaveTenant实体和这样的缓存项:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Phone : Entity, IMayHaveTenant</span><br><span class="line">&#123;</span><br><span class="line">    public int? TenantId &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public string Number &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[AutoMapFrom(typeof(Phone))]</span><br><span class="line">public class PhoneCacheItem</span><br><span class="line">&#123;</span><br><span class="line">    public string Number &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与实体缓存类似，为缓存类定义一个接口是可选的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IPhoneCache : IMultiTenancyEntityCache&lt;PhoneCacheItem&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，创建缓存类来缓存Phone实体:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PhoneCache : MayHaveTenantEntityCache&lt;Phone, PhoneCacheItem&gt;, IPhoneCache, ITransientDependency</span><br><span class="line">&#123;</span><br><span class="line">    public PhoneCache(ICacheManager cacheManager, IUnitOfWorkManager unitOfWorkManager, IRepository&lt;Phone&gt; repository)</span><br><span class="line">        : base(cacheManager, unitOfWorkManager, repository)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以在您的应用程序中以多租户安全的方式访问Phone实体缓存。它还具有EntityCache的所有优点，例如全局缓存，缓存类可以是瞬态/单态的。</p><h2 id="How-MustHaveTenantEntityCache-MayHaveTenantEntityCache-Works"><a href="#How-MustHaveTenantEntityCache-MayHaveTenantEntityCache-Works" class="headerlink" title="How MustHaveTenantEntityCache/MayHaveTenantEntityCache Works"></a>How MustHaveTenantEntityCache/MayHaveTenantEntityCache Works</h2><p>它的工作方式与EntityCache类似，但有一些区别。</p><ul><li>它在构造缓存键时使用TenantId。“{EntityId}@{TenantId}”。</li><li>这是多租户安全的。<br>如果需要更复杂的多租户缓存需求，可以扩展MultiTenancyEntityCache并添加自己的解决方案</li></ul><h2 id="Redis缓存集成"><a href="#Redis缓存集成" class="headerlink" title="Redis缓存集成"></a>Redis缓存集成</h2><p>默认的缓存管理器使用内存缓存。如果您有多个并发web服务器运行相同的应用程序，就会出现问题。在这种情况下，您可能需要一个分布式/中央缓存服务器。您可以轻松地使用Redis作为您的缓存服务器。<br>首先，您需要将Abp.RedisCache NuGet包安装到您的应用程序中(例如，您可以将它安装到您的Web项目中)。然后，您需要为AbpRedisCacheModule添加一个DependsOn属性，并在模块的PreInitialize方法中调用UseRedis扩展方法，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;...other namespaces</span><br><span class="line">using Abp.Runtime.Caching.Redis;</span><br><span class="line"></span><br><span class="line">namespace MyProject.AbpZeroTemplate.Web</span><br><span class="line">&#123;</span><br><span class="line">    [DependsOn(</span><br><span class="line">        &#x2F;&#x2F;...other module dependencies</span><br><span class="line">        typeof(AbpRedisCacheModule))]</span><br><span class="line">    public class MyProjectWebModule : AbpModule</span><br><span class="line">    &#123;</span><br><span class="line">        public override void PreInitialize()</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;...other configurations</span><br><span class="line"></span><br><span class="line">            Configuration.Caching.UseRedis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;...other code</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Abp.RedisCache package 默认使用”localhost” 作为链接字符串.您可以向配置文件中添加一个连接字符串来覆盖它。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;add name&#x3D;&quot;Abp.Redis.Cache&quot; connectionString&#x3D;&quot;localhost&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>此外，您还可以向appSettings添加一个设置来设置Redis的数据库id。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;add key&#x3D;&quot;Abp.Redis.Cache.DatabaseId&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>在ASP.NET Core中， 您可以使用UseRedis的委托参数覆盖它。例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Configuration.Caching.UseRedis(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.ConnectionString &#x3D; _appConfiguration[&quot;RedisCache:ConnectionString&quot;];</span><br><span class="line">    options.DatabaseId &#x3D; _appConfiguration.GetValue&lt;int&gt;(&quot;RedisCache:DatabaseId&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不同的数据库id对于在同一服务器中创建不同的键空间(隔离的缓存)很有用。</p><p>UseRedis方法还有一个重载，它采取一个动作来直接设置选项值(这个动作覆盖了配置文件中的值)。</p><p>有关Redis及其配置的更多信息，请参阅<a href="http://redis.io/documentation" target="_blank" rel="noopener">Redis文档</a>。</p><p>注意:应该安装并运行Redis服务器来使用ABP中的Redis缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;ABP提供了缓存的抽象。它在内部使用这个缓存抽象。虽然默认实现使用了MemoryCache，但它可以被实现并与任何其他缓存提供程序交换。例如
      
    
    </summary>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/categories/ABP/"/>
    
    
      <category term="ABP" scheme="https://www.smallapp.xyz/tags/ABP/"/>
    
  </entry>
  
</feed>
